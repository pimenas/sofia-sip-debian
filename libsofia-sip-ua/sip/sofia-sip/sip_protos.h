/* -*- C -*-
 *
 * This file is part of the Sofia-SIP package
 *
 * Copyright (C) 2005 Nokia Corporation.
 *
 * Contact: Pekka Pessi <pekka.pessi@nokia.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

#ifndef SIP_PROTOS_H
/** Defined when <sofia-sip/sip_protos.h> has been included. */
#define SIP_PROTOS_H 
  
/**@file sofia-sip/sip_protos.h
 * 
 * SIP prototypes and macros for each header.
 * 
 * This file is automatically generated from <sip.h> by msg_parser.awk.
 * 
 * @author Pekka Pessi <Pekka.Pessi@nokia.com>.
 *
 */

#include <sofia-sip/su_config.h>

#ifndef SIP_HEADER_H
#include <sofia-sip/sip_header.h>
#endif

#ifndef SIP_HCLASSES_H
#include <sofia-sip/sip_hclasses.h>
#endif

SOFIA_BEGIN_DECLS

#if SU_HAVE_INLINE
/** Get SIP structure from msg. */
su_inline
sip_t *sip_object(msg_t const *msg)
{
  return (sip_t *)msg_public(msg, SIP_PROTOCOL_TAG);
}

/** Insert a (list of) header(s) to the header structure and fragment chain.
 *
 * The function @c sip_header_insert() inserts header or list of headers
 * into a SIP message.  It also inserts them into the the message fragment
 * chain, if it exists.
 *
 * When inserting headers into the fragment chain, a request (or status) is
 * inserted first and replaces the existing request (or status).  The Via
 * headers are inserted after the request or status, and rest of the headers
 * after request, status, or Via headers.
 *
 * If the header is a singleton, existing headers with the same class are
 * removed.
 *
 * @param msg message owning the fragment chain
 * @param sip SIP message structure to which header is added
 * @param h   list of header(s) to be added
 */
su_inline
int sip_header_insert(msg_t *msg, sip_t *sip, sip_header_t *h)
{
  return msg_header_insert(msg, (msg_pub_t *)sip, (msg_header_t *)h);
}

/** Remove a header from a SIP message. */ 
su_inline
int sip_header_remove(msg_t *msg, sip_t *sip, sip_header_t *h)
{
  return msg_header_remove(msg, (msg_pub_t *)sip, (msg_header_t *)h);
}

/** Return name of the header. */
su_inline
char const *sip_header_name(sip_header_t const *h, int compact)
{
  if (compact && h->sh_class->hc_short[0])
    return h->sh_class->hc_short;
  else
    return h->sh_class->hc_name;
}

/** Return data after header structure. */
su_inline
void *sip_header_data(sip_header_t *h)
{
  return h && h != SIP_NONE ? h->sh_class->hc_size + (char *)h : NULL;
}
#else
sip_t *sip_object(msg_t *msg);
int sip_header_insert(msg_t *msg, sip_t *sip, sip_header_t *h);
int sip_header_remove(msg_t *msg, sip_t *sip, sip_header_t *h);
char const *sip_header_name(sip_header_t const *h, int compact);
void *sip_header_data(sip_header_t *h);
#endif

/**@addtogroup sip_request
 * @{
 */

/** Parse a request line. @internal */
SOFIAPUBFUN int sip_request_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a request line. @internal */
SOFIAPUBFUN int sip_request_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_request_t from sip_t.
 * 
 */
#define sip_request(sip) \
  ((sip_request_t *)msg_header_access((msg_pub_t*)(sip), sip_request_class))

/**Initializer for structure sip_request_t.
 * 
 * A static sip_request_t structure must be initialized.
 * The SIP_REQUEST_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_request_t sip_request = SIP_REQUEST_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REQUEST_INIT() SIP_HDR_INIT(request)

/**Initialize a structure sip_request_t.
 * 
 * An sip_request_t structure can be initialized with the
 * sip_request_init() function/macro. For instance,
 * @code
 * 
 *  sip_request_t sip_request;
 * 
 *  sip_request_init(&sip_request);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_request_t *sip_request_init(sip_request_t x[1])
{
  return SIP_HEADER_INIT(x, sip_request_class, sizeof(sip_request_t));
}
#else
#define sip_request_init(x) \
  SIP_HEADER_INIT(x, sip_request_class, sizeof(sip_request_t))
#endif

/**Test if header object is instance of sip_request_t.
 * 
 * The function sip_is_request() returns true (nonzero) if
 * the header class is an instance of request line
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_request() returns true (nonzero) if
 * the header object is an instance of header request and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_request(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_request_hash;
}
#else
int sip_is_request(sip_header_t const *header);
#endif

#define sip_request_p(h) sip_is_request((h))


/**Duplicate (deep copy) @c sip_request_t.
 * 
 * The function sip_request_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   request = sip_request_dup(home, sip->sip_request);
 * 
 * @endcode
 * 
 * @return
 * The function sip_request_dup() returns a pointer to the
 * newly duplicated sip_request_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_request_t *sip_request_dup(su_home_t *home, sip_request_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_request_t *sip_request_dup(su_home_t *home, sip_request_t const *hdr)
{ 
  return (sip_request_t *)
    msg_header_dup_as(home, sip_request_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_request_t header structure.
 * 
 * The function sip_request_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   request = sip_request_copy(home, sip->sip_request);
 * 
 * @endcode
 * 
 * @return
 * The function sip_request_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_request_t *sip_request_copy(su_home_t *home, sip_request_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_request_t *sip_request_copy(su_home_t *home, sip_request_t const *hdr) 
{ 
  return (sip_request_t *)
    msg_header_copy_as(home, sip_request_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_request_t.
 * 
 * The function sip_request_make() makes a new
 * sip_request_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_request_make() returns a pointer to
 * newly maked sip_request_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_request_t *sip_request_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_request_t *sip_request_make(su_home_t *home, char const *s)
{
  return (sip_request_t *)sip_header_make(home, sip_request_class, s);
}
#endif

/**Make a request line from formatting result.
 * 
 * The function sip_request_format() makes a new
 * request line object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_request_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_request_t *sip_request_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_request_t *sip_request_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_request_class, fmt, ap);
  va_end(ap);
 
  return (sip_request_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_status
 * @{
 */

/** Parse a status line. @internal */
SOFIAPUBFUN int sip_status_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a status line. @internal */
SOFIAPUBFUN int sip_status_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_status_t from sip_t.
 * 
 */
#define sip_status(sip) \
  ((sip_status_t *)msg_header_access((msg_pub_t*)(sip), sip_status_class))

/**Initializer for structure sip_status_t.
 * 
 * A static sip_status_t structure must be initialized.
 * The SIP_STATUS_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_status_t sip_status = SIP_STATUS_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_STATUS_INIT() SIP_HDR_INIT(status)

/**Initialize a structure sip_status_t.
 * 
 * An sip_status_t structure can be initialized with the
 * sip_status_init() function/macro. For instance,
 * @code
 * 
 *  sip_status_t sip_status;
 * 
 *  sip_status_init(&sip_status);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_status_t *sip_status_init(sip_status_t x[1])
{
  return SIP_HEADER_INIT(x, sip_status_class, sizeof(sip_status_t));
}
#else
#define sip_status_init(x) \
  SIP_HEADER_INIT(x, sip_status_class, sizeof(sip_status_t))
#endif

/**Test if header object is instance of sip_status_t.
 * 
 * The function sip_is_status() returns true (nonzero) if
 * the header class is an instance of status line
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_status() returns true (nonzero) if
 * the header object is an instance of header status and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_status(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_status_hash;
}
#else
int sip_is_status(sip_header_t const *header);
#endif

#define sip_status_p(h) sip_is_status((h))


/**Duplicate (deep copy) @c sip_status_t.
 * 
 * The function sip_status_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   status = sip_status_dup(home, sip->sip_status);
 * 
 * @endcode
 * 
 * @return
 * The function sip_status_dup() returns a pointer to the
 * newly duplicated sip_status_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_status_t *sip_status_dup(su_home_t *home, sip_status_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_status_t *sip_status_dup(su_home_t *home, sip_status_t const *hdr)
{ 
  return (sip_status_t *)
    msg_header_dup_as(home, sip_status_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_status_t header structure.
 * 
 * The function sip_status_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   status = sip_status_copy(home, sip->sip_status);
 * 
 * @endcode
 * 
 * @return
 * The function sip_status_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_status_t *sip_status_copy(su_home_t *home, sip_status_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_status_t *sip_status_copy(su_home_t *home, sip_status_t const *hdr) 
{ 
  return (sip_status_t *)
    msg_header_copy_as(home, sip_status_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_status_t.
 * 
 * The function sip_status_make() makes a new
 * sip_status_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_status_make() returns a pointer to
 * newly maked sip_status_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_status_t *sip_status_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_status_t *sip_status_make(su_home_t *home, char const *s)
{
  return (sip_status_t *)sip_header_make(home, sip_status_class, s);
}
#endif

/**Make a status line from formatting result.
 * 
 * The function sip_status_format() makes a new
 * status line object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_status_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_status_t *sip_status_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_status_t *sip_status_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_status_class, fmt, ap);
  va_end(ap);
 
  return (sip_status_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_via
 * @{
 */

/** Parse a Via header. @internal */
SOFIAPUBFUN int sip_via_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Via header. @internal */
SOFIAPUBFUN int sip_via_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_via_t from sip_t.
 * 
 */
#define sip_via(sip) \
  ((sip_via_t *)msg_header_access((msg_pub_t*)(sip), sip_via_class))

/**Initializer for structure sip_via_t.
 * 
 * A static sip_via_t structure must be initialized.
 * The SIP_VIA_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_via_t sip_via = SIP_VIA_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_VIA_INIT() SIP_HDR_INIT(via)

/**Initialize a structure sip_via_t.
 * 
 * An sip_via_t structure can be initialized with the
 * sip_via_init() function/macro. For instance,
 * @code
 * 
 *  sip_via_t sip_via;
 * 
 *  sip_via_init(&sip_via);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_via_t *sip_via_init(sip_via_t x[1])
{
  return SIP_HEADER_INIT(x, sip_via_class, sizeof(sip_via_t));
}
#else
#define sip_via_init(x) \
  SIP_HEADER_INIT(x, sip_via_class, sizeof(sip_via_t))
#endif

/**Test if header object is instance of sip_via_t.
 * 
 * The function sip_is_via() returns true (nonzero) if
 * the header class is an instance of Via header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_via() returns true (nonzero) if
 * the header object is an instance of header via and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_via(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_via_hash;
}
#else
int sip_is_via(sip_header_t const *header);
#endif

#define sip_via_p(h) sip_is_via((h))


/**Duplicate (deep copy) @c sip_via_t.
 * 
 * The function sip_via_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   via = sip_via_dup(home, sip->sip_via);
 * 
 * @endcode
 * 
 * @return
 * The function sip_via_dup() returns a pointer to the
 * newly duplicated sip_via_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_via_t *sip_via_dup(su_home_t *home, sip_via_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_via_t *sip_via_dup(su_home_t *home, sip_via_t const *hdr)
{ 
  return (sip_via_t *)
    msg_header_dup_as(home, sip_via_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_via_t header structure.
 * 
 * The function sip_via_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   via = sip_via_copy(home, sip->sip_via);
 * 
 * @endcode
 * 
 * @return
 * The function sip_via_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_via_t *sip_via_copy(su_home_t *home, sip_via_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_via_t *sip_via_copy(su_home_t *home, sip_via_t const *hdr) 
{ 
  return (sip_via_t *)
    msg_header_copy_as(home, sip_via_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_via_t.
 * 
 * The function sip_via_make() makes a new
 * sip_via_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_via_make() returns a pointer to
 * newly maked sip_via_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_via_t *sip_via_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_via_t *sip_via_make(su_home_t *home, char const *s)
{
  return (sip_via_t *)sip_header_make(home, sip_via_class, s);
}
#endif

/**Make a Via header from formatting result.
 * 
 * The function sip_via_format() makes a new
 * Via header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_via_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_via_t *sip_via_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_via_t *sip_via_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_via_class, fmt, ap);
  va_end(ap);
 
  return (sip_via_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_route
 * @{
 */

/** Parse a Route header. @internal */
SOFIAPUBFUN int sip_route_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Route header. @internal */
SOFIAPUBFUN int sip_route_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_route_t from sip_t.
 * 
 */
#define sip_route(sip) \
  ((sip_route_t *)msg_header_access((msg_pub_t*)(sip), sip_route_class))

/**Initializer for structure sip_route_t.
 * 
 * A static sip_route_t structure must be initialized.
 * The SIP_ROUTE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_route_t sip_route = SIP_ROUTE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ROUTE_INIT() SIP_HDR_INIT(route)

/**Initialize a structure sip_route_t.
 * 
 * An sip_route_t structure can be initialized with the
 * sip_route_init() function/macro. For instance,
 * @code
 * 
 *  sip_route_t sip_route;
 * 
 *  sip_route_init(&sip_route);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_route_t *sip_route_init(sip_route_t x[1])
{
  return SIP_HEADER_INIT(x, sip_route_class, sizeof(sip_route_t));
}
#else
#define sip_route_init(x) \
  SIP_HEADER_INIT(x, sip_route_class, sizeof(sip_route_t))
#endif

/**Test if header object is instance of sip_route_t.
 * 
 * The function sip_is_route() returns true (nonzero) if
 * the header class is an instance of Route header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_route() returns true (nonzero) if
 * the header object is an instance of header route and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_route(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_route_hash;
}
#else
int sip_is_route(sip_header_t const *header);
#endif

#define sip_route_p(h) sip_is_route((h))


/**Duplicate (deep copy) @c sip_route_t.
 * 
 * The function sip_route_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   route = sip_route_dup(home, sip->sip_route);
 * 
 * @endcode
 * 
 * @return
 * The function sip_route_dup() returns a pointer to the
 * newly duplicated sip_route_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_route_t *sip_route_dup(su_home_t *home, sip_route_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_route_t *sip_route_dup(su_home_t *home, sip_route_t const *hdr)
{ 
  return (sip_route_t *)
    msg_header_dup_as(home, sip_route_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_route_t header structure.
 * 
 * The function sip_route_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   route = sip_route_copy(home, sip->sip_route);
 * 
 * @endcode
 * 
 * @return
 * The function sip_route_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_route_t *sip_route_copy(su_home_t *home, sip_route_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_route_t *sip_route_copy(su_home_t *home, sip_route_t const *hdr) 
{ 
  return (sip_route_t *)
    msg_header_copy_as(home, sip_route_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_route_t.
 * 
 * The function sip_route_make() makes a new
 * sip_route_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_route_make() returns a pointer to
 * newly maked sip_route_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_route_t *sip_route_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_route_t *sip_route_make(su_home_t *home, char const *s)
{
  return (sip_route_t *)sip_header_make(home, sip_route_class, s);
}
#endif

/**Make a Route header from formatting result.
 * 
 * The function sip_route_format() makes a new
 * Route header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_route_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_route_t *sip_route_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_route_t *sip_route_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_route_class, fmt, ap);
  va_end(ap);
 
  return (sip_route_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_record_route
 * @{
 */

/** Parse a Record-Route header. @internal */
SOFIAPUBFUN int sip_record_route_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Record-Route header. @internal */
SOFIAPUBFUN int sip_record_route_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_record_route_t from sip_t.
 * 
 */
#define sip_record_route(sip) \
  ((sip_record_route_t *)msg_header_access((msg_pub_t*)(sip), sip_record_route_class))

/**Initializer for structure sip_record_route_t.
 * 
 * A static sip_record_route_t structure must be initialized.
 * The SIP_RECORD_ROUTE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_record_route_t sip_record_route = SIP_RECORD_ROUTE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_RECORD_ROUTE_INIT() SIP_HDR_INIT(record_route)

/**Initialize a structure sip_record_route_t.
 * 
 * An sip_record_route_t structure can be initialized with the
 * sip_record_route_init() function/macro. For instance,
 * @code
 * 
 *  sip_record_route_t sip_record_route;
 * 
 *  sip_record_route_init(&sip_record_route);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_record_route_t *sip_record_route_init(sip_record_route_t x[1])
{
  return SIP_HEADER_INIT(x, sip_record_route_class, sizeof(sip_record_route_t));
}
#else
#define sip_record_route_init(x) \
  SIP_HEADER_INIT(x, sip_record_route_class, sizeof(sip_record_route_t))
#endif

/**Test if header object is instance of sip_record_route_t.
 * 
 * The function sip_is_record_route() returns true (nonzero) if
 * the header class is an instance of Record-Route header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_record_route() returns true (nonzero) if
 * the header object is an instance of header record_route and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_record_route(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_record_route_hash;
}
#else
int sip_is_record_route(sip_header_t const *header);
#endif

#define sip_record_route_p(h) sip_is_record_route((h))


/**Duplicate (deep copy) @c sip_record_route_t.
 * 
 * The function sip_record_route_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   record_route = sip_record_route_dup(home, sip->sip_record_route);
 * 
 * @endcode
 * 
 * @return
 * The function sip_record_route_dup() returns a pointer to the
 * newly duplicated sip_record_route_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_record_route_t *sip_record_route_dup(su_home_t *home, sip_record_route_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_record_route_t *sip_record_route_dup(su_home_t *home, sip_record_route_t const *hdr)
{ 
  return (sip_record_route_t *)
    msg_header_dup_as(home, sip_record_route_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_record_route_t header structure.
 * 
 * The function sip_record_route_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   record_route = sip_record_route_copy(home, sip->sip_record_route);
 * 
 * @endcode
 * 
 * @return
 * The function sip_record_route_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_record_route_t *sip_record_route_copy(su_home_t *home, sip_record_route_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_record_route_t *sip_record_route_copy(su_home_t *home, sip_record_route_t const *hdr) 
{ 
  return (sip_record_route_t *)
    msg_header_copy_as(home, sip_record_route_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_record_route_t.
 * 
 * The function sip_record_route_make() makes a new
 * sip_record_route_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_record_route_make() returns a pointer to
 * newly maked sip_record_route_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_record_route_t *sip_record_route_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_record_route_t *sip_record_route_make(su_home_t *home, char const *s)
{
  return (sip_record_route_t *)sip_header_make(home, sip_record_route_class, s);
}
#endif

/**Make a Record-Route header from formatting result.
 * 
 * The function sip_record_route_format() makes a new
 * Record-Route header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_record_route_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_record_route_t *sip_record_route_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_record_route_t *sip_record_route_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_record_route_class, fmt, ap);
  va_end(ap);
 
  return (sip_record_route_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_max_forwards
 * @{
 */

/** Parse a Max-Forwards header. @internal */
SOFIAPUBFUN int sip_max_forwards_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Max-Forwards header. @internal */
SOFIAPUBFUN int sip_max_forwards_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_max_forwards_t from sip_t.
 * 
 */
#define sip_max_forwards(sip) \
  ((sip_max_forwards_t *)msg_header_access((msg_pub_t*)(sip), sip_max_forwards_class))

/**Initializer for structure sip_max_forwards_t.
 * 
 * A static sip_max_forwards_t structure must be initialized.
 * The SIP_MAX_FORWARDS_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_max_forwards_t sip_max_forwards = SIP_MAX_FORWARDS_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_MAX_FORWARDS_INIT() SIP_HDR_INIT(max_forwards)

/**Initialize a structure sip_max_forwards_t.
 * 
 * An sip_max_forwards_t structure can be initialized with the
 * sip_max_forwards_init() function/macro. For instance,
 * @code
 * 
 *  sip_max_forwards_t sip_max_forwards;
 * 
 *  sip_max_forwards_init(&sip_max_forwards);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_max_forwards_t *sip_max_forwards_init(sip_max_forwards_t x[1])
{
  return SIP_HEADER_INIT(x, sip_max_forwards_class, sizeof(sip_max_forwards_t));
}
#else
#define sip_max_forwards_init(x) \
  SIP_HEADER_INIT(x, sip_max_forwards_class, sizeof(sip_max_forwards_t))
#endif

/**Test if header object is instance of sip_max_forwards_t.
 * 
 * The function sip_is_max_forwards() returns true (nonzero) if
 * the header class is an instance of Max-Forwards header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_max_forwards() returns true (nonzero) if
 * the header object is an instance of header max_forwards and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_max_forwards(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_max_forwards_hash;
}
#else
int sip_is_max_forwards(sip_header_t const *header);
#endif

#define sip_max_forwards_p(h) sip_is_max_forwards((h))


/**Duplicate (deep copy) @c sip_max_forwards_t.
 * 
 * The function sip_max_forwards_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   max_forwards = sip_max_forwards_dup(home, sip->sip_max_forwards);
 * 
 * @endcode
 * 
 * @return
 * The function sip_max_forwards_dup() returns a pointer to the
 * newly duplicated sip_max_forwards_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_max_forwards_t *sip_max_forwards_dup(su_home_t *home, sip_max_forwards_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_max_forwards_t *sip_max_forwards_dup(su_home_t *home, sip_max_forwards_t const *hdr)
{ 
  return (sip_max_forwards_t *)
    msg_header_dup_as(home, sip_max_forwards_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_max_forwards_t header structure.
 * 
 * The function sip_max_forwards_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   max_forwards = sip_max_forwards_copy(home, sip->sip_max_forwards);
 * 
 * @endcode
 * 
 * @return
 * The function sip_max_forwards_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_max_forwards_t *sip_max_forwards_copy(su_home_t *home, sip_max_forwards_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_max_forwards_t *sip_max_forwards_copy(su_home_t *home, sip_max_forwards_t const *hdr) 
{ 
  return (sip_max_forwards_t *)
    msg_header_copy_as(home, sip_max_forwards_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_max_forwards_t.
 * 
 * The function sip_max_forwards_make() makes a new
 * sip_max_forwards_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_max_forwards_make() returns a pointer to
 * newly maked sip_max_forwards_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_max_forwards_t *sip_max_forwards_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_max_forwards_t *sip_max_forwards_make(su_home_t *home, char const *s)
{
  return (sip_max_forwards_t *)sip_header_make(home, sip_max_forwards_class, s);
}
#endif

/**Make a Max-Forwards header from formatting result.
 * 
 * The function sip_max_forwards_format() makes a new
 * Max-Forwards header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_max_forwards_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_max_forwards_t *sip_max_forwards_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_max_forwards_t *sip_max_forwards_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_max_forwards_class, fmt, ap);
  va_end(ap);
 
  return (sip_max_forwards_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_proxy_require
 * @{
 */

/** Parse a Proxy-Require header. @internal */
SOFIAPUBFUN int sip_proxy_require_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Proxy-Require header. @internal */
SOFIAPUBFUN int sip_proxy_require_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_proxy_require_t from sip_t.
 * 
 */
#define sip_proxy_require(sip) \
  ((sip_proxy_require_t *)msg_header_access((msg_pub_t*)(sip), sip_proxy_require_class))

/**Initializer for structure sip_proxy_require_t.
 * 
 * A static sip_proxy_require_t structure must be initialized.
 * The SIP_PROXY_REQUIRE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_proxy_require_t sip_proxy_require = SIP_PROXY_REQUIRE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PROXY_REQUIRE_INIT() SIP_HDR_INIT(proxy_require)

/**Initialize a structure sip_proxy_require_t.
 * 
 * An sip_proxy_require_t structure can be initialized with the
 * sip_proxy_require_init() function/macro. For instance,
 * @code
 * 
 *  sip_proxy_require_t sip_proxy_require;
 * 
 *  sip_proxy_require_init(&sip_proxy_require);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_proxy_require_t *sip_proxy_require_init(sip_proxy_require_t x[1])
{
  return SIP_HEADER_INIT(x, sip_proxy_require_class, sizeof(sip_proxy_require_t));
}
#else
#define sip_proxy_require_init(x) \
  SIP_HEADER_INIT(x, sip_proxy_require_class, sizeof(sip_proxy_require_t))
#endif

/**Test if header object is instance of sip_proxy_require_t.
 * 
 * The function sip_is_proxy_require() returns true (nonzero) if
 * the header class is an instance of Proxy-Require header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_proxy_require() returns true (nonzero) if
 * the header object is an instance of header proxy_require and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_proxy_require(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_proxy_require_hash;
}
#else
int sip_is_proxy_require(sip_header_t const *header);
#endif

#define sip_proxy_require_p(h) sip_is_proxy_require((h))


/**Duplicate (deep copy) @c sip_proxy_require_t.
 * 
 * The function sip_proxy_require_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   proxy_require = sip_proxy_require_dup(home, sip->sip_proxy_require);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_require_dup() returns a pointer to the
 * newly duplicated sip_proxy_require_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_require_t *sip_proxy_require_dup(su_home_t *home, sip_proxy_require_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_require_t *sip_proxy_require_dup(su_home_t *home, sip_proxy_require_t const *hdr)
{ 
  return (sip_proxy_require_t *)
    msg_header_dup_as(home, sip_proxy_require_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_proxy_require_t header structure.
 * 
 * The function sip_proxy_require_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   proxy_require = sip_proxy_require_copy(home, sip->sip_proxy_require);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_require_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_require_t *sip_proxy_require_copy(su_home_t *home, sip_proxy_require_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_require_t *sip_proxy_require_copy(su_home_t *home, sip_proxy_require_t const *hdr) 
{ 
  return (sip_proxy_require_t *)
    msg_header_copy_as(home, sip_proxy_require_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_proxy_require_t.
 * 
 * The function sip_proxy_require_make() makes a new
 * sip_proxy_require_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_proxy_require_make() returns a pointer to
 * newly maked sip_proxy_require_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_proxy_require_t *sip_proxy_require_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_proxy_require_t *sip_proxy_require_make(su_home_t *home, char const *s)
{
  return (sip_proxy_require_t *)sip_header_make(home, sip_proxy_require_class, s);
}
#endif

/**Make a Proxy-Require header from formatting result.
 * 
 * The function sip_proxy_require_format() makes a new
 * Proxy-Require header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_proxy_require_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_require_t *sip_proxy_require_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_proxy_require_t *sip_proxy_require_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_proxy_require_class, fmt, ap);
  va_end(ap);
 
  return (sip_proxy_require_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_from
 * @{
 */

/** Parse a From header. @internal */
SOFIAPUBFUN int sip_from_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a From header. @internal */
SOFIAPUBFUN int sip_from_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_from_t from sip_t.
 * 
 */
#define sip_from(sip) \
  ((sip_from_t *)msg_header_access((msg_pub_t*)(sip), sip_from_class))

/**Initializer for structure sip_from_t.
 * 
 * A static sip_from_t structure must be initialized.
 * The SIP_FROM_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_from_t sip_from = SIP_FROM_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_FROM_INIT() SIP_HDR_INIT(from)

/**Initialize a structure sip_from_t.
 * 
 * An sip_from_t structure can be initialized with the
 * sip_from_init() function/macro. For instance,
 * @code
 * 
 *  sip_from_t sip_from;
 * 
 *  sip_from_init(&sip_from);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_from_t *sip_from_init(sip_from_t x[1])
{
  return SIP_HEADER_INIT(x, sip_from_class, sizeof(sip_from_t));
}
#else
#define sip_from_init(x) \
  SIP_HEADER_INIT(x, sip_from_class, sizeof(sip_from_t))
#endif

/**Test if header object is instance of sip_from_t.
 * 
 * The function sip_is_from() returns true (nonzero) if
 * the header class is an instance of From header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_from() returns true (nonzero) if
 * the header object is an instance of header from and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_from(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_from_hash;
}
#else
int sip_is_from(sip_header_t const *header);
#endif

#define sip_from_p(h) sip_is_from((h))


/**Duplicate (deep copy) @c sip_from_t.
 * 
 * The function sip_from_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   from = sip_from_dup(home, sip->sip_from);
 * 
 * @endcode
 * 
 * @return
 * The function sip_from_dup() returns a pointer to the
 * newly duplicated sip_from_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_from_t *sip_from_dup(su_home_t *home, sip_from_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_from_t *sip_from_dup(su_home_t *home, sip_from_t const *hdr)
{ 
  return (sip_from_t *)
    msg_header_dup_as(home, sip_from_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_from_t header structure.
 * 
 * The function sip_from_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   from = sip_from_copy(home, sip->sip_from);
 * 
 * @endcode
 * 
 * @return
 * The function sip_from_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_from_t *sip_from_copy(su_home_t *home, sip_from_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_from_t *sip_from_copy(su_home_t *home, sip_from_t const *hdr) 
{ 
  return (sip_from_t *)
    msg_header_copy_as(home, sip_from_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_from_t.
 * 
 * The function sip_from_make() makes a new
 * sip_from_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_from_make() returns a pointer to
 * newly maked sip_from_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_from_t *sip_from_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_from_t *sip_from_make(su_home_t *home, char const *s)
{
  return (sip_from_t *)sip_header_make(home, sip_from_class, s);
}
#endif

/**Make a From header from formatting result.
 * 
 * The function sip_from_format() makes a new
 * From header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_from_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_from_t *sip_from_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_from_t *sip_from_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_from_class, fmt, ap);
  va_end(ap);
 
  return (sip_from_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_to
 * @{
 */

/** Parse a To header. @internal */
SOFIAPUBFUN int sip_to_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a To header. @internal */
SOFIAPUBFUN int sip_to_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_to_t from sip_t.
 * 
 */
#define sip_to(sip) \
  ((sip_to_t *)msg_header_access((msg_pub_t*)(sip), sip_to_class))

/**Initializer for structure sip_to_t.
 * 
 * A static sip_to_t structure must be initialized.
 * The SIP_TO_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_to_t sip_to = SIP_TO_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_TO_INIT() SIP_HDR_INIT(to)

/**Initialize a structure sip_to_t.
 * 
 * An sip_to_t structure can be initialized with the
 * sip_to_init() function/macro. For instance,
 * @code
 * 
 *  sip_to_t sip_to;
 * 
 *  sip_to_init(&sip_to);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_to_t *sip_to_init(sip_to_t x[1])
{
  return SIP_HEADER_INIT(x, sip_to_class, sizeof(sip_to_t));
}
#else
#define sip_to_init(x) \
  SIP_HEADER_INIT(x, sip_to_class, sizeof(sip_to_t))
#endif

/**Test if header object is instance of sip_to_t.
 * 
 * The function sip_is_to() returns true (nonzero) if
 * the header class is an instance of To header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_to() returns true (nonzero) if
 * the header object is an instance of header to and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_to(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_to_hash;
}
#else
int sip_is_to(sip_header_t const *header);
#endif

#define sip_to_p(h) sip_is_to((h))


/**Duplicate (deep copy) @c sip_to_t.
 * 
 * The function sip_to_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   to = sip_to_dup(home, sip->sip_to);
 * 
 * @endcode
 * 
 * @return
 * The function sip_to_dup() returns a pointer to the
 * newly duplicated sip_to_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_to_t *sip_to_dup(su_home_t *home, sip_to_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_to_t *sip_to_dup(su_home_t *home, sip_to_t const *hdr)
{ 
  return (sip_to_t *)
    msg_header_dup_as(home, sip_to_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_to_t header structure.
 * 
 * The function sip_to_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   to = sip_to_copy(home, sip->sip_to);
 * 
 * @endcode
 * 
 * @return
 * The function sip_to_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_to_t *sip_to_copy(su_home_t *home, sip_to_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_to_t *sip_to_copy(su_home_t *home, sip_to_t const *hdr) 
{ 
  return (sip_to_t *)
    msg_header_copy_as(home, sip_to_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_to_t.
 * 
 * The function sip_to_make() makes a new
 * sip_to_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_to_make() returns a pointer to
 * newly maked sip_to_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_to_t *sip_to_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_to_t *sip_to_make(su_home_t *home, char const *s)
{
  return (sip_to_t *)sip_header_make(home, sip_to_class, s);
}
#endif

/**Make a To header from formatting result.
 * 
 * The function sip_to_format() makes a new
 * To header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_to_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_to_t *sip_to_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_to_t *sip_to_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_to_class, fmt, ap);
  va_end(ap);
 
  return (sip_to_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_call_id
 * @{
 */

/** Parse a Call-ID header. @internal */
SOFIAPUBFUN int sip_call_id_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Call-ID header. @internal */
SOFIAPUBFUN int sip_call_id_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_call_id_t from sip_t.
 * 
 */
#define sip_call_id(sip) \
  ((sip_call_id_t *)msg_header_access((msg_pub_t*)(sip), sip_call_id_class))

/**Initializer for structure sip_call_id_t.
 * 
 * A static sip_call_id_t structure must be initialized.
 * The SIP_CALL_ID_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_call_id_t sip_call_id = SIP_CALL_ID_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CALL_ID_INIT() SIP_HDR_INIT(call_id)

/**Initialize a structure sip_call_id_t.
 * 
 * An sip_call_id_t structure can be initialized with the
 * sip_call_id_init() function/macro. For instance,
 * @code
 * 
 *  sip_call_id_t sip_call_id;
 * 
 *  sip_call_id_init(&sip_call_id);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_call_id_t *sip_call_id_init(sip_call_id_t x[1])
{
  return SIP_HEADER_INIT(x, sip_call_id_class, sizeof(sip_call_id_t));
}
#else
#define sip_call_id_init(x) \
  SIP_HEADER_INIT(x, sip_call_id_class, sizeof(sip_call_id_t))
#endif

/**Test if header object is instance of sip_call_id_t.
 * 
 * The function sip_is_call_id() returns true (nonzero) if
 * the header class is an instance of Call-ID header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_call_id() returns true (nonzero) if
 * the header object is an instance of header call_id and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_call_id(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_call_id_hash;
}
#else
int sip_is_call_id(sip_header_t const *header);
#endif

#define sip_call_id_p(h) sip_is_call_id((h))


/**Duplicate (deep copy) @c sip_call_id_t.
 * 
 * The function sip_call_id_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   call_id = sip_call_id_dup(home, sip->sip_call_id);
 * 
 * @endcode
 * 
 * @return
 * The function sip_call_id_dup() returns a pointer to the
 * newly duplicated sip_call_id_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_call_id_t *sip_call_id_dup(su_home_t *home, sip_call_id_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_call_id_t *sip_call_id_dup(su_home_t *home, sip_call_id_t const *hdr)
{ 
  return (sip_call_id_t *)
    msg_header_dup_as(home, sip_call_id_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_call_id_t header structure.
 * 
 * The function sip_call_id_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   call_id = sip_call_id_copy(home, sip->sip_call_id);
 * 
 * @endcode
 * 
 * @return
 * The function sip_call_id_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_call_id_t *sip_call_id_copy(su_home_t *home, sip_call_id_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_call_id_t *sip_call_id_copy(su_home_t *home, sip_call_id_t const *hdr) 
{ 
  return (sip_call_id_t *)
    msg_header_copy_as(home, sip_call_id_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_call_id_t.
 * 
 * The function sip_call_id_make() makes a new
 * sip_call_id_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_call_id_make() returns a pointer to
 * newly maked sip_call_id_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_call_id_t *sip_call_id_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_call_id_t *sip_call_id_make(su_home_t *home, char const *s)
{
  return (sip_call_id_t *)sip_header_make(home, sip_call_id_class, s);
}
#endif

/**Make a Call-ID header from formatting result.
 * 
 * The function sip_call_id_format() makes a new
 * Call-ID header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_call_id_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_call_id_t *sip_call_id_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_call_id_t *sip_call_id_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_call_id_class, fmt, ap);
  va_end(ap);
 
  return (sip_call_id_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_cseq
 * @{
 */

/** Parse a CSeq header. @internal */
SOFIAPUBFUN int sip_cseq_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a CSeq header. @internal */
SOFIAPUBFUN int sip_cseq_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_cseq_t from sip_t.
 * 
 */
#define sip_cseq(sip) \
  ((sip_cseq_t *)msg_header_access((msg_pub_t*)(sip), sip_cseq_class))

/**Initializer for structure sip_cseq_t.
 * 
 * A static sip_cseq_t structure must be initialized.
 * The SIP_CSEQ_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_cseq_t sip_cseq = SIP_CSEQ_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CSEQ_INIT() SIP_HDR_INIT(cseq)

/**Initialize a structure sip_cseq_t.
 * 
 * An sip_cseq_t structure can be initialized with the
 * sip_cseq_init() function/macro. For instance,
 * @code
 * 
 *  sip_cseq_t sip_cseq;
 * 
 *  sip_cseq_init(&sip_cseq);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_cseq_t *sip_cseq_init(sip_cseq_t x[1])
{
  return SIP_HEADER_INIT(x, sip_cseq_class, sizeof(sip_cseq_t));
}
#else
#define sip_cseq_init(x) \
  SIP_HEADER_INIT(x, sip_cseq_class, sizeof(sip_cseq_t))
#endif

/**Test if header object is instance of sip_cseq_t.
 * 
 * The function sip_is_cseq() returns true (nonzero) if
 * the header class is an instance of CSeq header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_cseq() returns true (nonzero) if
 * the header object is an instance of header cseq and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_cseq(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_cseq_hash;
}
#else
int sip_is_cseq(sip_header_t const *header);
#endif

#define sip_cseq_p(h) sip_is_cseq((h))


/**Duplicate (deep copy) @c sip_cseq_t.
 * 
 * The function sip_cseq_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   cseq = sip_cseq_dup(home, sip->sip_cseq);
 * 
 * @endcode
 * 
 * @return
 * The function sip_cseq_dup() returns a pointer to the
 * newly duplicated sip_cseq_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_cseq_t *sip_cseq_dup(su_home_t *home, sip_cseq_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_cseq_t *sip_cseq_dup(su_home_t *home, sip_cseq_t const *hdr)
{ 
  return (sip_cseq_t *)
    msg_header_dup_as(home, sip_cseq_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_cseq_t header structure.
 * 
 * The function sip_cseq_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   cseq = sip_cseq_copy(home, sip->sip_cseq);
 * 
 * @endcode
 * 
 * @return
 * The function sip_cseq_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_cseq_t *sip_cseq_copy(su_home_t *home, sip_cseq_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_cseq_t *sip_cseq_copy(su_home_t *home, sip_cseq_t const *hdr) 
{ 
  return (sip_cseq_t *)
    msg_header_copy_as(home, sip_cseq_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_cseq_t.
 * 
 * The function sip_cseq_make() makes a new
 * sip_cseq_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_cseq_make() returns a pointer to
 * newly maked sip_cseq_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_cseq_t *sip_cseq_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_cseq_t *sip_cseq_make(su_home_t *home, char const *s)
{
  return (sip_cseq_t *)sip_header_make(home, sip_cseq_class, s);
}
#endif

/**Make a CSeq header from formatting result.
 * 
 * The function sip_cseq_format() makes a new
 * CSeq header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_cseq_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_cseq_t *sip_cseq_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_cseq_t *sip_cseq_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_cseq_class, fmt, ap);
  va_end(ap);
 
  return (sip_cseq_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_contact
 * @{
 */

/** Parse a Contact header. @internal */
SOFIAPUBFUN int sip_contact_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Contact header. @internal */
SOFIAPUBFUN int sip_contact_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_contact_t from sip_t.
 * 
 */
#define sip_contact(sip) \
  ((sip_contact_t *)msg_header_access((msg_pub_t*)(sip), sip_contact_class))

/**Initializer for structure sip_contact_t.
 * 
 * A static sip_contact_t structure must be initialized.
 * The SIP_CONTACT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_contact_t sip_contact = SIP_CONTACT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CONTACT_INIT() SIP_HDR_INIT(contact)

/**Initialize a structure sip_contact_t.
 * 
 * An sip_contact_t structure can be initialized with the
 * sip_contact_init() function/macro. For instance,
 * @code
 * 
 *  sip_contact_t sip_contact;
 * 
 *  sip_contact_init(&sip_contact);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_contact_t *sip_contact_init(sip_contact_t x[1])
{
  return SIP_HEADER_INIT(x, sip_contact_class, sizeof(sip_contact_t));
}
#else
#define sip_contact_init(x) \
  SIP_HEADER_INIT(x, sip_contact_class, sizeof(sip_contact_t))
#endif

/**Test if header object is instance of sip_contact_t.
 * 
 * The function sip_is_contact() returns true (nonzero) if
 * the header class is an instance of Contact header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_contact() returns true (nonzero) if
 * the header object is an instance of header contact and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_contact(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_contact_hash;
}
#else
int sip_is_contact(sip_header_t const *header);
#endif

#define sip_contact_p(h) sip_is_contact((h))


/**Duplicate (deep copy) @c sip_contact_t.
 * 
 * The function sip_contact_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   contact = sip_contact_dup(home, sip->sip_contact);
 * 
 * @endcode
 * 
 * @return
 * The function sip_contact_dup() returns a pointer to the
 * newly duplicated sip_contact_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_contact_t *sip_contact_dup(su_home_t *home, sip_contact_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_contact_t *sip_contact_dup(su_home_t *home, sip_contact_t const *hdr)
{ 
  return (sip_contact_t *)
    msg_header_dup_as(home, sip_contact_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_contact_t header structure.
 * 
 * The function sip_contact_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   contact = sip_contact_copy(home, sip->sip_contact);
 * 
 * @endcode
 * 
 * @return
 * The function sip_contact_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_contact_t *sip_contact_copy(su_home_t *home, sip_contact_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_contact_t *sip_contact_copy(su_home_t *home, sip_contact_t const *hdr) 
{ 
  return (sip_contact_t *)
    msg_header_copy_as(home, sip_contact_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_contact_t.
 * 
 * The function sip_contact_make() makes a new
 * sip_contact_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_contact_make() returns a pointer to
 * newly maked sip_contact_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_contact_t *sip_contact_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_contact_t *sip_contact_make(su_home_t *home, char const *s)
{
  return (sip_contact_t *)sip_header_make(home, sip_contact_class, s);
}
#endif

/**Make a Contact header from formatting result.
 * 
 * The function sip_contact_format() makes a new
 * Contact header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_contact_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_contact_t *sip_contact_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_contact_t *sip_contact_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_contact_class, fmt, ap);
  va_end(ap);
 
  return (sip_contact_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_rseq
 * @{
 */

/** Parse a RSeq header. @internal */
SOFIAPUBFUN int sip_rseq_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a RSeq header. @internal */
SOFIAPUBFUN int sip_rseq_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_rseq_t from sip_t.
 * 
 */
#define sip_rseq(sip) \
  ((sip_rseq_t *)msg_header_access((msg_pub_t*)(sip), sip_rseq_class))

/**Initializer for structure sip_rseq_t.
 * 
 * A static sip_rseq_t structure must be initialized.
 * The SIP_RSEQ_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_rseq_t sip_rseq = SIP_RSEQ_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_RSEQ_INIT() SIP_HDR_INIT(rseq)

/**Initialize a structure sip_rseq_t.
 * 
 * An sip_rseq_t structure can be initialized with the
 * sip_rseq_init() function/macro. For instance,
 * @code
 * 
 *  sip_rseq_t sip_rseq;
 * 
 *  sip_rseq_init(&sip_rseq);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_rseq_t *sip_rseq_init(sip_rseq_t x[1])
{
  return SIP_HEADER_INIT(x, sip_rseq_class, sizeof(sip_rseq_t));
}
#else
#define sip_rseq_init(x) \
  SIP_HEADER_INIT(x, sip_rseq_class, sizeof(sip_rseq_t))
#endif

/**Test if header object is instance of sip_rseq_t.
 * 
 * The function sip_is_rseq() returns true (nonzero) if
 * the header class is an instance of RSeq header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_rseq() returns true (nonzero) if
 * the header object is an instance of header rseq and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_rseq(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_rseq_hash;
}
#else
int sip_is_rseq(sip_header_t const *header);
#endif

#define sip_rseq_p(h) sip_is_rseq((h))


/**Duplicate (deep copy) @c sip_rseq_t.
 * 
 * The function sip_rseq_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   rseq = sip_rseq_dup(home, sip->sip_rseq);
 * 
 * @endcode
 * 
 * @return
 * The function sip_rseq_dup() returns a pointer to the
 * newly duplicated sip_rseq_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_rseq_t *sip_rseq_dup(su_home_t *home, sip_rseq_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_rseq_t *sip_rseq_dup(su_home_t *home, sip_rseq_t const *hdr)
{ 
  return (sip_rseq_t *)
    msg_header_dup_as(home, sip_rseq_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_rseq_t header structure.
 * 
 * The function sip_rseq_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   rseq = sip_rseq_copy(home, sip->sip_rseq);
 * 
 * @endcode
 * 
 * @return
 * The function sip_rseq_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_rseq_t *sip_rseq_copy(su_home_t *home, sip_rseq_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_rseq_t *sip_rseq_copy(su_home_t *home, sip_rseq_t const *hdr) 
{ 
  return (sip_rseq_t *)
    msg_header_copy_as(home, sip_rseq_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_rseq_t.
 * 
 * The function sip_rseq_make() makes a new
 * sip_rseq_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_rseq_make() returns a pointer to
 * newly maked sip_rseq_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_rseq_t *sip_rseq_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_rseq_t *sip_rseq_make(su_home_t *home, char const *s)
{
  return (sip_rseq_t *)sip_header_make(home, sip_rseq_class, s);
}
#endif

/**Make a RSeq header from formatting result.
 * 
 * The function sip_rseq_format() makes a new
 * RSeq header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_rseq_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_rseq_t *sip_rseq_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_rseq_t *sip_rseq_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_rseq_class, fmt, ap);
  va_end(ap);
 
  return (sip_rseq_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_rack
 * @{
 */

/** Parse a RAck header. @internal */
SOFIAPUBFUN int sip_rack_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a RAck header. @internal */
SOFIAPUBFUN int sip_rack_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_rack_t from sip_t.
 * 
 */
#define sip_rack(sip) \
  ((sip_rack_t *)msg_header_access((msg_pub_t*)(sip), sip_rack_class))

/**Initializer for structure sip_rack_t.
 * 
 * A static sip_rack_t structure must be initialized.
 * The SIP_RACK_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_rack_t sip_rack = SIP_RACK_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_RACK_INIT() SIP_HDR_INIT(rack)

/**Initialize a structure sip_rack_t.
 * 
 * An sip_rack_t structure can be initialized with the
 * sip_rack_init() function/macro. For instance,
 * @code
 * 
 *  sip_rack_t sip_rack;
 * 
 *  sip_rack_init(&sip_rack);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_rack_t *sip_rack_init(sip_rack_t x[1])
{
  return SIP_HEADER_INIT(x, sip_rack_class, sizeof(sip_rack_t));
}
#else
#define sip_rack_init(x) \
  SIP_HEADER_INIT(x, sip_rack_class, sizeof(sip_rack_t))
#endif

/**Test if header object is instance of sip_rack_t.
 * 
 * The function sip_is_rack() returns true (nonzero) if
 * the header class is an instance of RAck header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_rack() returns true (nonzero) if
 * the header object is an instance of header rack and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_rack(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_rack_hash;
}
#else
int sip_is_rack(sip_header_t const *header);
#endif

#define sip_rack_p(h) sip_is_rack((h))


/**Duplicate (deep copy) @c sip_rack_t.
 * 
 * The function sip_rack_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   rack = sip_rack_dup(home, sip->sip_rack);
 * 
 * @endcode
 * 
 * @return
 * The function sip_rack_dup() returns a pointer to the
 * newly duplicated sip_rack_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_rack_t *sip_rack_dup(su_home_t *home, sip_rack_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_rack_t *sip_rack_dup(su_home_t *home, sip_rack_t const *hdr)
{ 
  return (sip_rack_t *)
    msg_header_dup_as(home, sip_rack_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_rack_t header structure.
 * 
 * The function sip_rack_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   rack = sip_rack_copy(home, sip->sip_rack);
 * 
 * @endcode
 * 
 * @return
 * The function sip_rack_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_rack_t *sip_rack_copy(su_home_t *home, sip_rack_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_rack_t *sip_rack_copy(su_home_t *home, sip_rack_t const *hdr) 
{ 
  return (sip_rack_t *)
    msg_header_copy_as(home, sip_rack_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_rack_t.
 * 
 * The function sip_rack_make() makes a new
 * sip_rack_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_rack_make() returns a pointer to
 * newly maked sip_rack_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_rack_t *sip_rack_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_rack_t *sip_rack_make(su_home_t *home, char const *s)
{
  return (sip_rack_t *)sip_header_make(home, sip_rack_class, s);
}
#endif

/**Make a RAck header from formatting result.
 * 
 * The function sip_rack_format() makes a new
 * RAck header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_rack_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_rack_t *sip_rack_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_rack_t *sip_rack_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_rack_class, fmt, ap);
  va_end(ap);
 
  return (sip_rack_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_request_disposition
 * @{
 */

/** Parse a Request-Disposition header. @internal */
SOFIAPUBFUN int sip_request_disposition_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Request-Disposition header. @internal */
SOFIAPUBFUN int sip_request_disposition_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_request_disposition_t from sip_t.
 * 
 */
#define sip_request_disposition(sip) \
  ((sip_request_disposition_t *)msg_header_access((msg_pub_t*)(sip), sip_request_disposition_class))

/**Initializer for structure sip_request_disposition_t.
 * 
 * A static sip_request_disposition_t structure must be initialized.
 * The SIP_REQUEST_DISPOSITION_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_request_disposition_t sip_request_disposition = SIP_REQUEST_DISPOSITION_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REQUEST_DISPOSITION_INIT() SIP_HDR_INIT(request_disposition)

/**Initialize a structure sip_request_disposition_t.
 * 
 * An sip_request_disposition_t structure can be initialized with the
 * sip_request_disposition_init() function/macro. For instance,
 * @code
 * 
 *  sip_request_disposition_t sip_request_disposition;
 * 
 *  sip_request_disposition_init(&sip_request_disposition);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_request_disposition_t *sip_request_disposition_init(sip_request_disposition_t x[1])
{
  return SIP_HEADER_INIT(x, sip_request_disposition_class, sizeof(sip_request_disposition_t));
}
#else
#define sip_request_disposition_init(x) \
  SIP_HEADER_INIT(x, sip_request_disposition_class, sizeof(sip_request_disposition_t))
#endif

/**Test if header object is instance of sip_request_disposition_t.
 * 
 * The function sip_is_request_disposition() returns true (nonzero) if
 * the header class is an instance of Request-Disposition header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_request_disposition() returns true (nonzero) if
 * the header object is an instance of header request_disposition and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_request_disposition(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_request_disposition_hash;
}
#else
int sip_is_request_disposition(sip_header_t const *header);
#endif

#define sip_request_disposition_p(h) sip_is_request_disposition((h))


/**Duplicate (deep copy) @c sip_request_disposition_t.
 * 
 * The function sip_request_disposition_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   request_disposition = sip_request_disposition_dup(home, sip->sip_request_disposition);
 * 
 * @endcode
 * 
 * @return
 * The function sip_request_disposition_dup() returns a pointer to the
 * newly duplicated sip_request_disposition_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_request_disposition_t *sip_request_disposition_dup(su_home_t *home, sip_request_disposition_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_request_disposition_t *sip_request_disposition_dup(su_home_t *home, sip_request_disposition_t const *hdr)
{ 
  return (sip_request_disposition_t *)
    msg_header_dup_as(home, sip_request_disposition_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_request_disposition_t header structure.
 * 
 * The function sip_request_disposition_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   request_disposition = sip_request_disposition_copy(home, sip->sip_request_disposition);
 * 
 * @endcode
 * 
 * @return
 * The function sip_request_disposition_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_request_disposition_t *sip_request_disposition_copy(su_home_t *home, sip_request_disposition_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_request_disposition_t *sip_request_disposition_copy(su_home_t *home, sip_request_disposition_t const *hdr) 
{ 
  return (sip_request_disposition_t *)
    msg_header_copy_as(home, sip_request_disposition_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_request_disposition_t.
 * 
 * The function sip_request_disposition_make() makes a new
 * sip_request_disposition_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_request_disposition_make() returns a pointer to
 * newly maked sip_request_disposition_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_request_disposition_t *sip_request_disposition_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_request_disposition_t *sip_request_disposition_make(su_home_t *home, char const *s)
{
  return (sip_request_disposition_t *)sip_header_make(home, sip_request_disposition_class, s);
}
#endif

/**Make a Request-Disposition header from formatting result.
 * 
 * The function sip_request_disposition_format() makes a new
 * Request-Disposition header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_request_disposition_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_request_disposition_t *sip_request_disposition_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_request_disposition_t *sip_request_disposition_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_request_disposition_class, fmt, ap);
  va_end(ap);
 
  return (sip_request_disposition_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_accept_contact
 * @{
 */

/** Parse a Accept-Contact header. @internal */
SOFIAPUBFUN int sip_accept_contact_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Accept-Contact header. @internal */
SOFIAPUBFUN int sip_accept_contact_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_accept_contact_t from sip_t.
 * 
 */
#define sip_accept_contact(sip) \
  ((sip_accept_contact_t *)msg_header_access((msg_pub_t*)(sip), sip_accept_contact_class))

/**Initializer for structure sip_accept_contact_t.
 * 
 * A static sip_accept_contact_t structure must be initialized.
 * The SIP_ACCEPT_CONTACT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_accept_contact_t sip_accept_contact = SIP_ACCEPT_CONTACT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ACCEPT_CONTACT_INIT() SIP_HDR_INIT(accept_contact)

/**Initialize a structure sip_accept_contact_t.
 * 
 * An sip_accept_contact_t structure can be initialized with the
 * sip_accept_contact_init() function/macro. For instance,
 * @code
 * 
 *  sip_accept_contact_t sip_accept_contact;
 * 
 *  sip_accept_contact_init(&sip_accept_contact);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_accept_contact_t *sip_accept_contact_init(sip_accept_contact_t x[1])
{
  return SIP_HEADER_INIT(x, sip_accept_contact_class, sizeof(sip_accept_contact_t));
}
#else
#define sip_accept_contact_init(x) \
  SIP_HEADER_INIT(x, sip_accept_contact_class, sizeof(sip_accept_contact_t))
#endif

/**Test if header object is instance of sip_accept_contact_t.
 * 
 * The function sip_is_accept_contact() returns true (nonzero) if
 * the header class is an instance of Accept-Contact header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_accept_contact() returns true (nonzero) if
 * the header object is an instance of header accept_contact and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_accept_contact(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_accept_contact_hash;
}
#else
int sip_is_accept_contact(sip_header_t const *header);
#endif

#define sip_accept_contact_p(h) sip_is_accept_contact((h))


/**Duplicate (deep copy) @c sip_accept_contact_t.
 * 
 * The function sip_accept_contact_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   accept_contact = sip_accept_contact_dup(home, sip->sip_accept_contact);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_contact_dup() returns a pointer to the
 * newly duplicated sip_accept_contact_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_contact_t *sip_accept_contact_dup(su_home_t *home, sip_accept_contact_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_contact_t *sip_accept_contact_dup(su_home_t *home, sip_accept_contact_t const *hdr)
{ 
  return (sip_accept_contact_t *)
    msg_header_dup_as(home, sip_accept_contact_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_accept_contact_t header structure.
 * 
 * The function sip_accept_contact_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   accept_contact = sip_accept_contact_copy(home, sip->sip_accept_contact);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_contact_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_contact_t *sip_accept_contact_copy(su_home_t *home, sip_accept_contact_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_contact_t *sip_accept_contact_copy(su_home_t *home, sip_accept_contact_t const *hdr) 
{ 
  return (sip_accept_contact_t *)
    msg_header_copy_as(home, sip_accept_contact_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_accept_contact_t.
 * 
 * The function sip_accept_contact_make() makes a new
 * sip_accept_contact_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_accept_contact_make() returns a pointer to
 * newly maked sip_accept_contact_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_accept_contact_t *sip_accept_contact_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_accept_contact_t *sip_accept_contact_make(su_home_t *home, char const *s)
{
  return (sip_accept_contact_t *)sip_header_make(home, sip_accept_contact_class, s);
}
#endif

/**Make a Accept-Contact header from formatting result.
 * 
 * The function sip_accept_contact_format() makes a new
 * Accept-Contact header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_accept_contact_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_contact_t *sip_accept_contact_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_accept_contact_t *sip_accept_contact_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_accept_contact_class, fmt, ap);
  va_end(ap);
 
  return (sip_accept_contact_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_reject_contact
 * @{
 */

/** Parse a Reject-Contact header. @internal */
SOFIAPUBFUN int sip_reject_contact_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Reject-Contact header. @internal */
SOFIAPUBFUN int sip_reject_contact_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_reject_contact_t from sip_t.
 * 
 */
#define sip_reject_contact(sip) \
  ((sip_reject_contact_t *)msg_header_access((msg_pub_t*)(sip), sip_reject_contact_class))

/**Initializer for structure sip_reject_contact_t.
 * 
 * A static sip_reject_contact_t structure must be initialized.
 * The SIP_REJECT_CONTACT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_reject_contact_t sip_reject_contact = SIP_REJECT_CONTACT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REJECT_CONTACT_INIT() SIP_HDR_INIT(reject_contact)

/**Initialize a structure sip_reject_contact_t.
 * 
 * An sip_reject_contact_t structure can be initialized with the
 * sip_reject_contact_init() function/macro. For instance,
 * @code
 * 
 *  sip_reject_contact_t sip_reject_contact;
 * 
 *  sip_reject_contact_init(&sip_reject_contact);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_reject_contact_t *sip_reject_contact_init(sip_reject_contact_t x[1])
{
  return SIP_HEADER_INIT(x, sip_reject_contact_class, sizeof(sip_reject_contact_t));
}
#else
#define sip_reject_contact_init(x) \
  SIP_HEADER_INIT(x, sip_reject_contact_class, sizeof(sip_reject_contact_t))
#endif

/**Test if header object is instance of sip_reject_contact_t.
 * 
 * The function sip_is_reject_contact() returns true (nonzero) if
 * the header class is an instance of Reject-Contact header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_reject_contact() returns true (nonzero) if
 * the header object is an instance of header reject_contact and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_reject_contact(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_reject_contact_hash;
}
#else
int sip_is_reject_contact(sip_header_t const *header);
#endif

#define sip_reject_contact_p(h) sip_is_reject_contact((h))


/**Duplicate (deep copy) @c sip_reject_contact_t.
 * 
 * The function sip_reject_contact_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   reject_contact = sip_reject_contact_dup(home, sip->sip_reject_contact);
 * 
 * @endcode
 * 
 * @return
 * The function sip_reject_contact_dup() returns a pointer to the
 * newly duplicated sip_reject_contact_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_reject_contact_t *sip_reject_contact_dup(su_home_t *home, sip_reject_contact_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_reject_contact_t *sip_reject_contact_dup(su_home_t *home, sip_reject_contact_t const *hdr)
{ 
  return (sip_reject_contact_t *)
    msg_header_dup_as(home, sip_reject_contact_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_reject_contact_t header structure.
 * 
 * The function sip_reject_contact_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   reject_contact = sip_reject_contact_copy(home, sip->sip_reject_contact);
 * 
 * @endcode
 * 
 * @return
 * The function sip_reject_contact_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_reject_contact_t *sip_reject_contact_copy(su_home_t *home, sip_reject_contact_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_reject_contact_t *sip_reject_contact_copy(su_home_t *home, sip_reject_contact_t const *hdr) 
{ 
  return (sip_reject_contact_t *)
    msg_header_copy_as(home, sip_reject_contact_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_reject_contact_t.
 * 
 * The function sip_reject_contact_make() makes a new
 * sip_reject_contact_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_reject_contact_make() returns a pointer to
 * newly maked sip_reject_contact_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_reject_contact_t *sip_reject_contact_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_reject_contact_t *sip_reject_contact_make(su_home_t *home, char const *s)
{
  return (sip_reject_contact_t *)sip_header_make(home, sip_reject_contact_class, s);
}
#endif

/**Make a Reject-Contact header from formatting result.
 * 
 * The function sip_reject_contact_format() makes a new
 * Reject-Contact header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_reject_contact_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_reject_contact_t *sip_reject_contact_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_reject_contact_t *sip_reject_contact_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_reject_contact_class, fmt, ap);
  va_end(ap);
 
  return (sip_reject_contact_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_expires
 * @{
 */

/** Parse a Expires header. @internal */
SOFIAPUBFUN int sip_expires_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Expires header. @internal */
SOFIAPUBFUN int sip_expires_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_expires_t from sip_t.
 * 
 */
#define sip_expires(sip) \
  ((sip_expires_t *)msg_header_access((msg_pub_t*)(sip), sip_expires_class))

/**Initializer for structure sip_expires_t.
 * 
 * A static sip_expires_t structure must be initialized.
 * The SIP_EXPIRES_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_expires_t sip_expires = SIP_EXPIRES_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_EXPIRES_INIT() SIP_HDR_INIT(expires)

/**Initialize a structure sip_expires_t.
 * 
 * An sip_expires_t structure can be initialized with the
 * sip_expires_init() function/macro. For instance,
 * @code
 * 
 *  sip_expires_t sip_expires;
 * 
 *  sip_expires_init(&sip_expires);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_expires_t *sip_expires_init(sip_expires_t x[1])
{
  return SIP_HEADER_INIT(x, sip_expires_class, sizeof(sip_expires_t));
}
#else
#define sip_expires_init(x) \
  SIP_HEADER_INIT(x, sip_expires_class, sizeof(sip_expires_t))
#endif

/**Test if header object is instance of sip_expires_t.
 * 
 * The function sip_is_expires() returns true (nonzero) if
 * the header class is an instance of Expires header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_expires() returns true (nonzero) if
 * the header object is an instance of header expires and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_expires(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_expires_hash;
}
#else
int sip_is_expires(sip_header_t const *header);
#endif

#define sip_expires_p(h) sip_is_expires((h))


/**Duplicate (deep copy) @c sip_expires_t.
 * 
 * The function sip_expires_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   expires = sip_expires_dup(home, sip->sip_expires);
 * 
 * @endcode
 * 
 * @return
 * The function sip_expires_dup() returns a pointer to the
 * newly duplicated sip_expires_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_expires_t *sip_expires_dup(su_home_t *home, sip_expires_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_expires_t *sip_expires_dup(su_home_t *home, sip_expires_t const *hdr)
{ 
  return (sip_expires_t *)
    msg_header_dup_as(home, sip_expires_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_expires_t header structure.
 * 
 * The function sip_expires_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   expires = sip_expires_copy(home, sip->sip_expires);
 * 
 * @endcode
 * 
 * @return
 * The function sip_expires_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_expires_t *sip_expires_copy(su_home_t *home, sip_expires_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_expires_t *sip_expires_copy(su_home_t *home, sip_expires_t const *hdr) 
{ 
  return (sip_expires_t *)
    msg_header_copy_as(home, sip_expires_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_expires_t.
 * 
 * The function sip_expires_make() makes a new
 * sip_expires_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_expires_make() returns a pointer to
 * newly maked sip_expires_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_expires_t *sip_expires_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_expires_t *sip_expires_make(su_home_t *home, char const *s)
{
  return (sip_expires_t *)sip_header_make(home, sip_expires_class, s);
}
#endif

/**Make a Expires header from formatting result.
 * 
 * The function sip_expires_format() makes a new
 * Expires header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_expires_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_expires_t *sip_expires_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_expires_t *sip_expires_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_expires_class, fmt, ap);
  va_end(ap);
 
  return (sip_expires_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_date
 * @{
 */

/** Parse a Date header. @internal */
SOFIAPUBFUN int sip_date_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Date header. @internal */
SOFIAPUBFUN int sip_date_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_date_t from sip_t.
 * 
 */
#define sip_date(sip) \
  ((sip_date_t *)msg_header_access((msg_pub_t*)(sip), sip_date_class))

/**Initializer for structure sip_date_t.
 * 
 * A static sip_date_t structure must be initialized.
 * The SIP_DATE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_date_t sip_date = SIP_DATE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_DATE_INIT() SIP_HDR_INIT(date)

/**Initialize a structure sip_date_t.
 * 
 * An sip_date_t structure can be initialized with the
 * sip_date_init() function/macro. For instance,
 * @code
 * 
 *  sip_date_t sip_date;
 * 
 *  sip_date_init(&sip_date);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_date_t *sip_date_init(sip_date_t x[1])
{
  return SIP_HEADER_INIT(x, sip_date_class, sizeof(sip_date_t));
}
#else
#define sip_date_init(x) \
  SIP_HEADER_INIT(x, sip_date_class, sizeof(sip_date_t))
#endif

/**Test if header object is instance of sip_date_t.
 * 
 * The function sip_is_date() returns true (nonzero) if
 * the header class is an instance of Date header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_date() returns true (nonzero) if
 * the header object is an instance of header date and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_date(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_date_hash;
}
#else
int sip_is_date(sip_header_t const *header);
#endif

#define sip_date_p(h) sip_is_date((h))


/**Duplicate (deep copy) @c sip_date_t.
 * 
 * The function sip_date_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   date = sip_date_dup(home, sip->sip_date);
 * 
 * @endcode
 * 
 * @return
 * The function sip_date_dup() returns a pointer to the
 * newly duplicated sip_date_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_date_t *sip_date_dup(su_home_t *home, sip_date_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_date_t *sip_date_dup(su_home_t *home, sip_date_t const *hdr)
{ 
  return (sip_date_t *)
    msg_header_dup_as(home, sip_date_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_date_t header structure.
 * 
 * The function sip_date_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   date = sip_date_copy(home, sip->sip_date);
 * 
 * @endcode
 * 
 * @return
 * The function sip_date_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_date_t *sip_date_copy(su_home_t *home, sip_date_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_date_t *sip_date_copy(su_home_t *home, sip_date_t const *hdr) 
{ 
  return (sip_date_t *)
    msg_header_copy_as(home, sip_date_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_date_t.
 * 
 * The function sip_date_make() makes a new
 * sip_date_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_date_make() returns a pointer to
 * newly maked sip_date_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_date_t *sip_date_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_date_t *sip_date_make(su_home_t *home, char const *s)
{
  return (sip_date_t *)sip_header_make(home, sip_date_class, s);
}
#endif

/**Make a Date header from formatting result.
 * 
 * The function sip_date_format() makes a new
 * Date header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_date_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_date_t *sip_date_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_date_t *sip_date_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_date_class, fmt, ap);
  va_end(ap);
 
  return (sip_date_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_retry_after
 * @{
 */

/** Parse a Retry-After header. @internal */
SOFIAPUBFUN int sip_retry_after_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Retry-After header. @internal */
SOFIAPUBFUN int sip_retry_after_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_retry_after_t from sip_t.
 * 
 */
#define sip_retry_after(sip) \
  ((sip_retry_after_t *)msg_header_access((msg_pub_t*)(sip), sip_retry_after_class))

/**Initializer for structure sip_retry_after_t.
 * 
 * A static sip_retry_after_t structure must be initialized.
 * The SIP_RETRY_AFTER_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_retry_after_t sip_retry_after = SIP_RETRY_AFTER_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_RETRY_AFTER_INIT() SIP_HDR_INIT(retry_after)

/**Initialize a structure sip_retry_after_t.
 * 
 * An sip_retry_after_t structure can be initialized with the
 * sip_retry_after_init() function/macro. For instance,
 * @code
 * 
 *  sip_retry_after_t sip_retry_after;
 * 
 *  sip_retry_after_init(&sip_retry_after);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_retry_after_t *sip_retry_after_init(sip_retry_after_t x[1])
{
  return SIP_HEADER_INIT(x, sip_retry_after_class, sizeof(sip_retry_after_t));
}
#else
#define sip_retry_after_init(x) \
  SIP_HEADER_INIT(x, sip_retry_after_class, sizeof(sip_retry_after_t))
#endif

/**Test if header object is instance of sip_retry_after_t.
 * 
 * The function sip_is_retry_after() returns true (nonzero) if
 * the header class is an instance of Retry-After header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_retry_after() returns true (nonzero) if
 * the header object is an instance of header retry_after and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_retry_after(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_retry_after_hash;
}
#else
int sip_is_retry_after(sip_header_t const *header);
#endif

#define sip_retry_after_p(h) sip_is_retry_after((h))


/**Duplicate (deep copy) @c sip_retry_after_t.
 * 
 * The function sip_retry_after_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   retry_after = sip_retry_after_dup(home, sip->sip_retry_after);
 * 
 * @endcode
 * 
 * @return
 * The function sip_retry_after_dup() returns a pointer to the
 * newly duplicated sip_retry_after_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_retry_after_t *sip_retry_after_dup(su_home_t *home, sip_retry_after_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_retry_after_t *sip_retry_after_dup(su_home_t *home, sip_retry_after_t const *hdr)
{ 
  return (sip_retry_after_t *)
    msg_header_dup_as(home, sip_retry_after_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_retry_after_t header structure.
 * 
 * The function sip_retry_after_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   retry_after = sip_retry_after_copy(home, sip->sip_retry_after);
 * 
 * @endcode
 * 
 * @return
 * The function sip_retry_after_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_retry_after_t *sip_retry_after_copy(su_home_t *home, sip_retry_after_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_retry_after_t *sip_retry_after_copy(su_home_t *home, sip_retry_after_t const *hdr) 
{ 
  return (sip_retry_after_t *)
    msg_header_copy_as(home, sip_retry_after_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_retry_after_t.
 * 
 * The function sip_retry_after_make() makes a new
 * sip_retry_after_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_retry_after_make() returns a pointer to
 * newly maked sip_retry_after_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_retry_after_t *sip_retry_after_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_retry_after_t *sip_retry_after_make(su_home_t *home, char const *s)
{
  return (sip_retry_after_t *)sip_header_make(home, sip_retry_after_class, s);
}
#endif

/**Make a Retry-After header from formatting result.
 * 
 * The function sip_retry_after_format() makes a new
 * Retry-After header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_retry_after_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_retry_after_t *sip_retry_after_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_retry_after_t *sip_retry_after_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_retry_after_class, fmt, ap);
  va_end(ap);
 
  return (sip_retry_after_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_timestamp
 * @{
 */

/** Parse a Timestamp header. @internal */
SOFIAPUBFUN int sip_timestamp_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Timestamp header. @internal */
SOFIAPUBFUN int sip_timestamp_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_timestamp_t from sip_t.
 * 
 */
#define sip_timestamp(sip) \
  ((sip_timestamp_t *)msg_header_access((msg_pub_t*)(sip), sip_timestamp_class))

/**Initializer for structure sip_timestamp_t.
 * 
 * A static sip_timestamp_t structure must be initialized.
 * The SIP_TIMESTAMP_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_timestamp_t sip_timestamp = SIP_TIMESTAMP_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_TIMESTAMP_INIT() SIP_HDR_INIT(timestamp)

/**Initialize a structure sip_timestamp_t.
 * 
 * An sip_timestamp_t structure can be initialized with the
 * sip_timestamp_init() function/macro. For instance,
 * @code
 * 
 *  sip_timestamp_t sip_timestamp;
 * 
 *  sip_timestamp_init(&sip_timestamp);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_timestamp_t *sip_timestamp_init(sip_timestamp_t x[1])
{
  return SIP_HEADER_INIT(x, sip_timestamp_class, sizeof(sip_timestamp_t));
}
#else
#define sip_timestamp_init(x) \
  SIP_HEADER_INIT(x, sip_timestamp_class, sizeof(sip_timestamp_t))
#endif

/**Test if header object is instance of sip_timestamp_t.
 * 
 * The function sip_is_timestamp() returns true (nonzero) if
 * the header class is an instance of Timestamp header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_timestamp() returns true (nonzero) if
 * the header object is an instance of header timestamp and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_timestamp(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_timestamp_hash;
}
#else
int sip_is_timestamp(sip_header_t const *header);
#endif

#define sip_timestamp_p(h) sip_is_timestamp((h))


/**Duplicate (deep copy) @c sip_timestamp_t.
 * 
 * The function sip_timestamp_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   timestamp = sip_timestamp_dup(home, sip->sip_timestamp);
 * 
 * @endcode
 * 
 * @return
 * The function sip_timestamp_dup() returns a pointer to the
 * newly duplicated sip_timestamp_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_timestamp_t *sip_timestamp_dup(su_home_t *home, sip_timestamp_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_timestamp_t *sip_timestamp_dup(su_home_t *home, sip_timestamp_t const *hdr)
{ 
  return (sip_timestamp_t *)
    msg_header_dup_as(home, sip_timestamp_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_timestamp_t header structure.
 * 
 * The function sip_timestamp_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   timestamp = sip_timestamp_copy(home, sip->sip_timestamp);
 * 
 * @endcode
 * 
 * @return
 * The function sip_timestamp_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_timestamp_t *sip_timestamp_copy(su_home_t *home, sip_timestamp_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_timestamp_t *sip_timestamp_copy(su_home_t *home, sip_timestamp_t const *hdr) 
{ 
  return (sip_timestamp_t *)
    msg_header_copy_as(home, sip_timestamp_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_timestamp_t.
 * 
 * The function sip_timestamp_make() makes a new
 * sip_timestamp_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_timestamp_make() returns a pointer to
 * newly maked sip_timestamp_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_timestamp_t *sip_timestamp_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_timestamp_t *sip_timestamp_make(su_home_t *home, char const *s)
{
  return (sip_timestamp_t *)sip_header_make(home, sip_timestamp_class, s);
}
#endif

/**Make a Timestamp header from formatting result.
 * 
 * The function sip_timestamp_format() makes a new
 * Timestamp header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_timestamp_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_timestamp_t *sip_timestamp_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_timestamp_t *sip_timestamp_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_timestamp_class, fmt, ap);
  va_end(ap);
 
  return (sip_timestamp_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_min_expires
 * @{
 */

/** Parse a Min-Expires header. @internal */
SOFIAPUBFUN int sip_min_expires_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Min-Expires header. @internal */
SOFIAPUBFUN int sip_min_expires_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_min_expires_t from sip_t.
 * 
 */
#define sip_min_expires(sip) \
  ((sip_min_expires_t *)msg_header_access((msg_pub_t*)(sip), sip_min_expires_class))

/**Initializer for structure sip_min_expires_t.
 * 
 * A static sip_min_expires_t structure must be initialized.
 * The SIP_MIN_EXPIRES_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_min_expires_t sip_min_expires = SIP_MIN_EXPIRES_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_MIN_EXPIRES_INIT() SIP_HDR_INIT(min_expires)

/**Initialize a structure sip_min_expires_t.
 * 
 * An sip_min_expires_t structure can be initialized with the
 * sip_min_expires_init() function/macro. For instance,
 * @code
 * 
 *  sip_min_expires_t sip_min_expires;
 * 
 *  sip_min_expires_init(&sip_min_expires);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_min_expires_t *sip_min_expires_init(sip_min_expires_t x[1])
{
  return SIP_HEADER_INIT(x, sip_min_expires_class, sizeof(sip_min_expires_t));
}
#else
#define sip_min_expires_init(x) \
  SIP_HEADER_INIT(x, sip_min_expires_class, sizeof(sip_min_expires_t))
#endif

/**Test if header object is instance of sip_min_expires_t.
 * 
 * The function sip_is_min_expires() returns true (nonzero) if
 * the header class is an instance of Min-Expires header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_min_expires() returns true (nonzero) if
 * the header object is an instance of header min_expires and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_min_expires(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_min_expires_hash;
}
#else
int sip_is_min_expires(sip_header_t const *header);
#endif

#define sip_min_expires_p(h) sip_is_min_expires((h))


/**Duplicate (deep copy) @c sip_min_expires_t.
 * 
 * The function sip_min_expires_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   min_expires = sip_min_expires_dup(home, sip->sip_min_expires);
 * 
 * @endcode
 * 
 * @return
 * The function sip_min_expires_dup() returns a pointer to the
 * newly duplicated sip_min_expires_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_min_expires_t *sip_min_expires_dup(su_home_t *home, sip_min_expires_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_min_expires_t *sip_min_expires_dup(su_home_t *home, sip_min_expires_t const *hdr)
{ 
  return (sip_min_expires_t *)
    msg_header_dup_as(home, sip_min_expires_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_min_expires_t header structure.
 * 
 * The function sip_min_expires_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   min_expires = sip_min_expires_copy(home, sip->sip_min_expires);
 * 
 * @endcode
 * 
 * @return
 * The function sip_min_expires_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_min_expires_t *sip_min_expires_copy(su_home_t *home, sip_min_expires_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_min_expires_t *sip_min_expires_copy(su_home_t *home, sip_min_expires_t const *hdr) 
{ 
  return (sip_min_expires_t *)
    msg_header_copy_as(home, sip_min_expires_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_min_expires_t.
 * 
 * The function sip_min_expires_make() makes a new
 * sip_min_expires_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_min_expires_make() returns a pointer to
 * newly maked sip_min_expires_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_min_expires_t *sip_min_expires_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_min_expires_t *sip_min_expires_make(su_home_t *home, char const *s)
{
  return (sip_min_expires_t *)sip_header_make(home, sip_min_expires_class, s);
}
#endif

/**Make a Min-Expires header from formatting result.
 * 
 * The function sip_min_expires_format() makes a new
 * Min-Expires header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_min_expires_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_min_expires_t *sip_min_expires_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_min_expires_t *sip_min_expires_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_min_expires_class, fmt, ap);
  va_end(ap);
 
  return (sip_min_expires_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_subject
 * @{
 */

/** Parse a Subject header. @internal */
SOFIAPUBFUN int sip_subject_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Subject header. @internal */
SOFIAPUBFUN int sip_subject_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_subject_t from sip_t.
 * 
 */
#define sip_subject(sip) \
  ((sip_subject_t *)msg_header_access((msg_pub_t*)(sip), sip_subject_class))

/**Initializer for structure sip_subject_t.
 * 
 * A static sip_subject_t structure must be initialized.
 * The SIP_SUBJECT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_subject_t sip_subject = SIP_SUBJECT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SUBJECT_INIT() SIP_HDR_INIT(subject)

/**Initialize a structure sip_subject_t.
 * 
 * An sip_subject_t structure can be initialized with the
 * sip_subject_init() function/macro. For instance,
 * @code
 * 
 *  sip_subject_t sip_subject;
 * 
 *  sip_subject_init(&sip_subject);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_subject_t *sip_subject_init(sip_subject_t x[1])
{
  return SIP_HEADER_INIT(x, sip_subject_class, sizeof(sip_subject_t));
}
#else
#define sip_subject_init(x) \
  SIP_HEADER_INIT(x, sip_subject_class, sizeof(sip_subject_t))
#endif

/**Test if header object is instance of sip_subject_t.
 * 
 * The function sip_is_subject() returns true (nonzero) if
 * the header class is an instance of Subject header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_subject() returns true (nonzero) if
 * the header object is an instance of header subject and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_subject(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_subject_hash;
}
#else
int sip_is_subject(sip_header_t const *header);
#endif

#define sip_subject_p(h) sip_is_subject((h))


/**Duplicate (deep copy) @c sip_subject_t.
 * 
 * The function sip_subject_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   subject = sip_subject_dup(home, sip->sip_subject);
 * 
 * @endcode
 * 
 * @return
 * The function sip_subject_dup() returns a pointer to the
 * newly duplicated sip_subject_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_subject_t *sip_subject_dup(su_home_t *home, sip_subject_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_subject_t *sip_subject_dup(su_home_t *home, sip_subject_t const *hdr)
{ 
  return (sip_subject_t *)
    msg_header_dup_as(home, sip_subject_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_subject_t header structure.
 * 
 * The function sip_subject_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   subject = sip_subject_copy(home, sip->sip_subject);
 * 
 * @endcode
 * 
 * @return
 * The function sip_subject_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_subject_t *sip_subject_copy(su_home_t *home, sip_subject_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_subject_t *sip_subject_copy(su_home_t *home, sip_subject_t const *hdr) 
{ 
  return (sip_subject_t *)
    msg_header_copy_as(home, sip_subject_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_subject_t.
 * 
 * The function sip_subject_make() makes a new
 * sip_subject_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_subject_make() returns a pointer to
 * newly maked sip_subject_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_subject_t *sip_subject_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_subject_t *sip_subject_make(su_home_t *home, char const *s)
{
  return (sip_subject_t *)sip_header_make(home, sip_subject_class, s);
}
#endif

/**Make a Subject header from formatting result.
 * 
 * The function sip_subject_format() makes a new
 * Subject header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_subject_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_subject_t *sip_subject_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_subject_t *sip_subject_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_subject_class, fmt, ap);
  va_end(ap);
 
  return (sip_subject_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_priority
 * @{
 */

/** Parse a Priority header. @internal */
SOFIAPUBFUN int sip_priority_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Priority header. @internal */
SOFIAPUBFUN int sip_priority_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_priority_t from sip_t.
 * 
 */
#define sip_priority(sip) \
  ((sip_priority_t *)msg_header_access((msg_pub_t*)(sip), sip_priority_class))

/**Initializer for structure sip_priority_t.
 * 
 * A static sip_priority_t structure must be initialized.
 * The SIP_PRIORITY_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_priority_t sip_priority = SIP_PRIORITY_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PRIORITY_INIT() SIP_HDR_INIT(priority)

/**Initialize a structure sip_priority_t.
 * 
 * An sip_priority_t structure can be initialized with the
 * sip_priority_init() function/macro. For instance,
 * @code
 * 
 *  sip_priority_t sip_priority;
 * 
 *  sip_priority_init(&sip_priority);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_priority_t *sip_priority_init(sip_priority_t x[1])
{
  return SIP_HEADER_INIT(x, sip_priority_class, sizeof(sip_priority_t));
}
#else
#define sip_priority_init(x) \
  SIP_HEADER_INIT(x, sip_priority_class, sizeof(sip_priority_t))
#endif

/**Test if header object is instance of sip_priority_t.
 * 
 * The function sip_is_priority() returns true (nonzero) if
 * the header class is an instance of Priority header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_priority() returns true (nonzero) if
 * the header object is an instance of header priority and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_priority(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_priority_hash;
}
#else
int sip_is_priority(sip_header_t const *header);
#endif

#define sip_priority_p(h) sip_is_priority((h))


/**Duplicate (deep copy) @c sip_priority_t.
 * 
 * The function sip_priority_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   priority = sip_priority_dup(home, sip->sip_priority);
 * 
 * @endcode
 * 
 * @return
 * The function sip_priority_dup() returns a pointer to the
 * newly duplicated sip_priority_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_priority_t *sip_priority_dup(su_home_t *home, sip_priority_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_priority_t *sip_priority_dup(su_home_t *home, sip_priority_t const *hdr)
{ 
  return (sip_priority_t *)
    msg_header_dup_as(home, sip_priority_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_priority_t header structure.
 * 
 * The function sip_priority_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   priority = sip_priority_copy(home, sip->sip_priority);
 * 
 * @endcode
 * 
 * @return
 * The function sip_priority_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_priority_t *sip_priority_copy(su_home_t *home, sip_priority_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_priority_t *sip_priority_copy(su_home_t *home, sip_priority_t const *hdr) 
{ 
  return (sip_priority_t *)
    msg_header_copy_as(home, sip_priority_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_priority_t.
 * 
 * The function sip_priority_make() makes a new
 * sip_priority_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_priority_make() returns a pointer to
 * newly maked sip_priority_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_priority_t *sip_priority_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_priority_t *sip_priority_make(su_home_t *home, char const *s)
{
  return (sip_priority_t *)sip_header_make(home, sip_priority_class, s);
}
#endif

/**Make a Priority header from formatting result.
 * 
 * The function sip_priority_format() makes a new
 * Priority header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_priority_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_priority_t *sip_priority_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_priority_t *sip_priority_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_priority_class, fmt, ap);
  va_end(ap);
 
  return (sip_priority_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_call_info
 * @{
 */

/** Parse a Call-Info header. @internal */
SOFIAPUBFUN int sip_call_info_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Call-Info header. @internal */
SOFIAPUBFUN int sip_call_info_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_call_info_t from sip_t.
 * 
 */
#define sip_call_info(sip) \
  ((sip_call_info_t *)msg_header_access((msg_pub_t*)(sip), sip_call_info_class))

/**Initializer for structure sip_call_info_t.
 * 
 * A static sip_call_info_t structure must be initialized.
 * The SIP_CALL_INFO_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_call_info_t sip_call_info = SIP_CALL_INFO_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CALL_INFO_INIT() SIP_HDR_INIT(call_info)

/**Initialize a structure sip_call_info_t.
 * 
 * An sip_call_info_t structure can be initialized with the
 * sip_call_info_init() function/macro. For instance,
 * @code
 * 
 *  sip_call_info_t sip_call_info;
 * 
 *  sip_call_info_init(&sip_call_info);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_call_info_t *sip_call_info_init(sip_call_info_t x[1])
{
  return SIP_HEADER_INIT(x, sip_call_info_class, sizeof(sip_call_info_t));
}
#else
#define sip_call_info_init(x) \
  SIP_HEADER_INIT(x, sip_call_info_class, sizeof(sip_call_info_t))
#endif

/**Test if header object is instance of sip_call_info_t.
 * 
 * The function sip_is_call_info() returns true (nonzero) if
 * the header class is an instance of Call-Info header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_call_info() returns true (nonzero) if
 * the header object is an instance of header call_info and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_call_info(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_call_info_hash;
}
#else
int sip_is_call_info(sip_header_t const *header);
#endif

#define sip_call_info_p(h) sip_is_call_info((h))


/**Duplicate (deep copy) @c sip_call_info_t.
 * 
 * The function sip_call_info_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   call_info = sip_call_info_dup(home, sip->sip_call_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_call_info_dup() returns a pointer to the
 * newly duplicated sip_call_info_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_call_info_t *sip_call_info_dup(su_home_t *home, sip_call_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_call_info_t *sip_call_info_dup(su_home_t *home, sip_call_info_t const *hdr)
{ 
  return (sip_call_info_t *)
    msg_header_dup_as(home, sip_call_info_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_call_info_t header structure.
 * 
 * The function sip_call_info_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   call_info = sip_call_info_copy(home, sip->sip_call_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_call_info_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_call_info_t *sip_call_info_copy(su_home_t *home, sip_call_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_call_info_t *sip_call_info_copy(su_home_t *home, sip_call_info_t const *hdr) 
{ 
  return (sip_call_info_t *)
    msg_header_copy_as(home, sip_call_info_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_call_info_t.
 * 
 * The function sip_call_info_make() makes a new
 * sip_call_info_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_call_info_make() returns a pointer to
 * newly maked sip_call_info_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_call_info_t *sip_call_info_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_call_info_t *sip_call_info_make(su_home_t *home, char const *s)
{
  return (sip_call_info_t *)sip_header_make(home, sip_call_info_class, s);
}
#endif

/**Make a Call-Info header from formatting result.
 * 
 * The function sip_call_info_format() makes a new
 * Call-Info header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_call_info_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_call_info_t *sip_call_info_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_call_info_t *sip_call_info_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_call_info_class, fmt, ap);
  va_end(ap);
 
  return (sip_call_info_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_organization
 * @{
 */

/** Parse a Organization header. @internal */
SOFIAPUBFUN int sip_organization_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Organization header. @internal */
SOFIAPUBFUN int sip_organization_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_organization_t from sip_t.
 * 
 */
#define sip_organization(sip) \
  ((sip_organization_t *)msg_header_access((msg_pub_t*)(sip), sip_organization_class))

/**Initializer for structure sip_organization_t.
 * 
 * A static sip_organization_t structure must be initialized.
 * The SIP_ORGANIZATION_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_organization_t sip_organization = SIP_ORGANIZATION_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ORGANIZATION_INIT() SIP_HDR_INIT(organization)

/**Initialize a structure sip_organization_t.
 * 
 * An sip_organization_t structure can be initialized with the
 * sip_organization_init() function/macro. For instance,
 * @code
 * 
 *  sip_organization_t sip_organization;
 * 
 *  sip_organization_init(&sip_organization);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_organization_t *sip_organization_init(sip_organization_t x[1])
{
  return SIP_HEADER_INIT(x, sip_organization_class, sizeof(sip_organization_t));
}
#else
#define sip_organization_init(x) \
  SIP_HEADER_INIT(x, sip_organization_class, sizeof(sip_organization_t))
#endif

/**Test if header object is instance of sip_organization_t.
 * 
 * The function sip_is_organization() returns true (nonzero) if
 * the header class is an instance of Organization header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_organization() returns true (nonzero) if
 * the header object is an instance of header organization and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_organization(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_organization_hash;
}
#else
int sip_is_organization(sip_header_t const *header);
#endif

#define sip_organization_p(h) sip_is_organization((h))


/**Duplicate (deep copy) @c sip_organization_t.
 * 
 * The function sip_organization_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   organization = sip_organization_dup(home, sip->sip_organization);
 * 
 * @endcode
 * 
 * @return
 * The function sip_organization_dup() returns a pointer to the
 * newly duplicated sip_organization_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_organization_t *sip_organization_dup(su_home_t *home, sip_organization_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_organization_t *sip_organization_dup(su_home_t *home, sip_organization_t const *hdr)
{ 
  return (sip_organization_t *)
    msg_header_dup_as(home, sip_organization_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_organization_t header structure.
 * 
 * The function sip_organization_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   organization = sip_organization_copy(home, sip->sip_organization);
 * 
 * @endcode
 * 
 * @return
 * The function sip_organization_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_organization_t *sip_organization_copy(su_home_t *home, sip_organization_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_organization_t *sip_organization_copy(su_home_t *home, sip_organization_t const *hdr) 
{ 
  return (sip_organization_t *)
    msg_header_copy_as(home, sip_organization_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_organization_t.
 * 
 * The function sip_organization_make() makes a new
 * sip_organization_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_organization_make() returns a pointer to
 * newly maked sip_organization_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_organization_t *sip_organization_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_organization_t *sip_organization_make(su_home_t *home, char const *s)
{
  return (sip_organization_t *)sip_header_make(home, sip_organization_class, s);
}
#endif

/**Make a Organization header from formatting result.
 * 
 * The function sip_organization_format() makes a new
 * Organization header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_organization_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_organization_t *sip_organization_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_organization_t *sip_organization_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_organization_class, fmt, ap);
  va_end(ap);
 
  return (sip_organization_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_server
 * @{
 */

/** Parse a Server header. @internal */
SOFIAPUBFUN int sip_server_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Server header. @internal */
SOFIAPUBFUN int sip_server_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_server_t from sip_t.
 * 
 */
#define sip_server(sip) \
  ((sip_server_t *)msg_header_access((msg_pub_t*)(sip), sip_server_class))

/**Initializer for structure sip_server_t.
 * 
 * A static sip_server_t structure must be initialized.
 * The SIP_SERVER_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_server_t sip_server = SIP_SERVER_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SERVER_INIT() SIP_HDR_INIT(server)

/**Initialize a structure sip_server_t.
 * 
 * An sip_server_t structure can be initialized with the
 * sip_server_init() function/macro. For instance,
 * @code
 * 
 *  sip_server_t sip_server;
 * 
 *  sip_server_init(&sip_server);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_server_t *sip_server_init(sip_server_t x[1])
{
  return SIP_HEADER_INIT(x, sip_server_class, sizeof(sip_server_t));
}
#else
#define sip_server_init(x) \
  SIP_HEADER_INIT(x, sip_server_class, sizeof(sip_server_t))
#endif

/**Test if header object is instance of sip_server_t.
 * 
 * The function sip_is_server() returns true (nonzero) if
 * the header class is an instance of Server header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_server() returns true (nonzero) if
 * the header object is an instance of header server and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_server(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_server_hash;
}
#else
int sip_is_server(sip_header_t const *header);
#endif

#define sip_server_p(h) sip_is_server((h))


/**Duplicate (deep copy) @c sip_server_t.
 * 
 * The function sip_server_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   server = sip_server_dup(home, sip->sip_server);
 * 
 * @endcode
 * 
 * @return
 * The function sip_server_dup() returns a pointer to the
 * newly duplicated sip_server_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_server_t *sip_server_dup(su_home_t *home, sip_server_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_server_t *sip_server_dup(su_home_t *home, sip_server_t const *hdr)
{ 
  return (sip_server_t *)
    msg_header_dup_as(home, sip_server_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_server_t header structure.
 * 
 * The function sip_server_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   server = sip_server_copy(home, sip->sip_server);
 * 
 * @endcode
 * 
 * @return
 * The function sip_server_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_server_t *sip_server_copy(su_home_t *home, sip_server_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_server_t *sip_server_copy(su_home_t *home, sip_server_t const *hdr) 
{ 
  return (sip_server_t *)
    msg_header_copy_as(home, sip_server_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_server_t.
 * 
 * The function sip_server_make() makes a new
 * sip_server_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_server_make() returns a pointer to
 * newly maked sip_server_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_server_t *sip_server_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_server_t *sip_server_make(su_home_t *home, char const *s)
{
  return (sip_server_t *)sip_header_make(home, sip_server_class, s);
}
#endif

/**Make a Server header from formatting result.
 * 
 * The function sip_server_format() makes a new
 * Server header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_server_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_server_t *sip_server_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_server_t *sip_server_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_server_class, fmt, ap);
  va_end(ap);
 
  return (sip_server_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_user_agent
 * @{
 */

/** Parse a User-Agent header. @internal */
SOFIAPUBFUN int sip_user_agent_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a User-Agent header. @internal */
SOFIAPUBFUN int sip_user_agent_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_user_agent_t from sip_t.
 * 
 */
#define sip_user_agent(sip) \
  ((sip_user_agent_t *)msg_header_access((msg_pub_t*)(sip), sip_user_agent_class))

/**Initializer for structure sip_user_agent_t.
 * 
 * A static sip_user_agent_t structure must be initialized.
 * The SIP_USER_AGENT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_user_agent_t sip_user_agent = SIP_USER_AGENT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_USER_AGENT_INIT() SIP_HDR_INIT(user_agent)

/**Initialize a structure sip_user_agent_t.
 * 
 * An sip_user_agent_t structure can be initialized with the
 * sip_user_agent_init() function/macro. For instance,
 * @code
 * 
 *  sip_user_agent_t sip_user_agent;
 * 
 *  sip_user_agent_init(&sip_user_agent);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_user_agent_t *sip_user_agent_init(sip_user_agent_t x[1])
{
  return SIP_HEADER_INIT(x, sip_user_agent_class, sizeof(sip_user_agent_t));
}
#else
#define sip_user_agent_init(x) \
  SIP_HEADER_INIT(x, sip_user_agent_class, sizeof(sip_user_agent_t))
#endif

/**Test if header object is instance of sip_user_agent_t.
 * 
 * The function sip_is_user_agent() returns true (nonzero) if
 * the header class is an instance of User-Agent header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_user_agent() returns true (nonzero) if
 * the header object is an instance of header user_agent and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_user_agent(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_user_agent_hash;
}
#else
int sip_is_user_agent(sip_header_t const *header);
#endif

#define sip_user_agent_p(h) sip_is_user_agent((h))


/**Duplicate (deep copy) @c sip_user_agent_t.
 * 
 * The function sip_user_agent_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   user_agent = sip_user_agent_dup(home, sip->sip_user_agent);
 * 
 * @endcode
 * 
 * @return
 * The function sip_user_agent_dup() returns a pointer to the
 * newly duplicated sip_user_agent_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_user_agent_t *sip_user_agent_dup(su_home_t *home, sip_user_agent_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_user_agent_t *sip_user_agent_dup(su_home_t *home, sip_user_agent_t const *hdr)
{ 
  return (sip_user_agent_t *)
    msg_header_dup_as(home, sip_user_agent_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_user_agent_t header structure.
 * 
 * The function sip_user_agent_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   user_agent = sip_user_agent_copy(home, sip->sip_user_agent);
 * 
 * @endcode
 * 
 * @return
 * The function sip_user_agent_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_user_agent_t *sip_user_agent_copy(su_home_t *home, sip_user_agent_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_user_agent_t *sip_user_agent_copy(su_home_t *home, sip_user_agent_t const *hdr) 
{ 
  return (sip_user_agent_t *)
    msg_header_copy_as(home, sip_user_agent_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_user_agent_t.
 * 
 * The function sip_user_agent_make() makes a new
 * sip_user_agent_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_user_agent_make() returns a pointer to
 * newly maked sip_user_agent_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_user_agent_t *sip_user_agent_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_user_agent_t *sip_user_agent_make(su_home_t *home, char const *s)
{
  return (sip_user_agent_t *)sip_header_make(home, sip_user_agent_class, s);
}
#endif

/**Make a User-Agent header from formatting result.
 * 
 * The function sip_user_agent_format() makes a new
 * User-Agent header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_user_agent_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_user_agent_t *sip_user_agent_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_user_agent_t *sip_user_agent_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_user_agent_class, fmt, ap);
  va_end(ap);
 
  return (sip_user_agent_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_in_reply_to
 * @{
 */

/** Parse a In-Reply-To header. @internal */
SOFIAPUBFUN int sip_in_reply_to_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a In-Reply-To header. @internal */
SOFIAPUBFUN int sip_in_reply_to_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_in_reply_to_t from sip_t.
 * 
 */
#define sip_in_reply_to(sip) \
  ((sip_in_reply_to_t *)msg_header_access((msg_pub_t*)(sip), sip_in_reply_to_class))

/**Initializer for structure sip_in_reply_to_t.
 * 
 * A static sip_in_reply_to_t structure must be initialized.
 * The SIP_IN_REPLY_TO_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_in_reply_to_t sip_in_reply_to = SIP_IN_REPLY_TO_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_IN_REPLY_TO_INIT() SIP_HDR_INIT(in_reply_to)

/**Initialize a structure sip_in_reply_to_t.
 * 
 * An sip_in_reply_to_t structure can be initialized with the
 * sip_in_reply_to_init() function/macro. For instance,
 * @code
 * 
 *  sip_in_reply_to_t sip_in_reply_to;
 * 
 *  sip_in_reply_to_init(&sip_in_reply_to);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_in_reply_to_t *sip_in_reply_to_init(sip_in_reply_to_t x[1])
{
  return SIP_HEADER_INIT(x, sip_in_reply_to_class, sizeof(sip_in_reply_to_t));
}
#else
#define sip_in_reply_to_init(x) \
  SIP_HEADER_INIT(x, sip_in_reply_to_class, sizeof(sip_in_reply_to_t))
#endif

/**Test if header object is instance of sip_in_reply_to_t.
 * 
 * The function sip_is_in_reply_to() returns true (nonzero) if
 * the header class is an instance of In-Reply-To header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_in_reply_to() returns true (nonzero) if
 * the header object is an instance of header in_reply_to and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_in_reply_to(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_in_reply_to_hash;
}
#else
int sip_is_in_reply_to(sip_header_t const *header);
#endif

#define sip_in_reply_to_p(h) sip_is_in_reply_to((h))


/**Duplicate (deep copy) @c sip_in_reply_to_t.
 * 
 * The function sip_in_reply_to_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   in_reply_to = sip_in_reply_to_dup(home, sip->sip_in_reply_to);
 * 
 * @endcode
 * 
 * @return
 * The function sip_in_reply_to_dup() returns a pointer to the
 * newly duplicated sip_in_reply_to_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_in_reply_to_t *sip_in_reply_to_dup(su_home_t *home, sip_in_reply_to_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_in_reply_to_t *sip_in_reply_to_dup(su_home_t *home, sip_in_reply_to_t const *hdr)
{ 
  return (sip_in_reply_to_t *)
    msg_header_dup_as(home, sip_in_reply_to_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_in_reply_to_t header structure.
 * 
 * The function sip_in_reply_to_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   in_reply_to = sip_in_reply_to_copy(home, sip->sip_in_reply_to);
 * 
 * @endcode
 * 
 * @return
 * The function sip_in_reply_to_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_in_reply_to_t *sip_in_reply_to_copy(su_home_t *home, sip_in_reply_to_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_in_reply_to_t *sip_in_reply_to_copy(su_home_t *home, sip_in_reply_to_t const *hdr) 
{ 
  return (sip_in_reply_to_t *)
    msg_header_copy_as(home, sip_in_reply_to_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_in_reply_to_t.
 * 
 * The function sip_in_reply_to_make() makes a new
 * sip_in_reply_to_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_in_reply_to_make() returns a pointer to
 * newly maked sip_in_reply_to_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_in_reply_to_t *sip_in_reply_to_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_in_reply_to_t *sip_in_reply_to_make(su_home_t *home, char const *s)
{
  return (sip_in_reply_to_t *)sip_header_make(home, sip_in_reply_to_class, s);
}
#endif

/**Make a In-Reply-To header from formatting result.
 * 
 * The function sip_in_reply_to_format() makes a new
 * In-Reply-To header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_in_reply_to_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_in_reply_to_t *sip_in_reply_to_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_in_reply_to_t *sip_in_reply_to_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_in_reply_to_class, fmt, ap);
  va_end(ap);
 
  return (sip_in_reply_to_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_accept
 * @{
 */

/** Parse a Accept header. @internal */
SOFIAPUBFUN int sip_accept_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Accept header. @internal */
SOFIAPUBFUN int sip_accept_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_accept_t from sip_t.
 * 
 */
#define sip_accept(sip) \
  ((sip_accept_t *)msg_header_access((msg_pub_t*)(sip), sip_accept_class))

/**Initializer for structure sip_accept_t.
 * 
 * A static sip_accept_t structure must be initialized.
 * The SIP_ACCEPT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_accept_t sip_accept = SIP_ACCEPT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ACCEPT_INIT() SIP_HDR_INIT(accept)

/**Initialize a structure sip_accept_t.
 * 
 * An sip_accept_t structure can be initialized with the
 * sip_accept_init() function/macro. For instance,
 * @code
 * 
 *  sip_accept_t sip_accept;
 * 
 *  sip_accept_init(&sip_accept);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_accept_t *sip_accept_init(sip_accept_t x[1])
{
  return SIP_HEADER_INIT(x, sip_accept_class, sizeof(sip_accept_t));
}
#else
#define sip_accept_init(x) \
  SIP_HEADER_INIT(x, sip_accept_class, sizeof(sip_accept_t))
#endif

/**Test if header object is instance of sip_accept_t.
 * 
 * The function sip_is_accept() returns true (nonzero) if
 * the header class is an instance of Accept header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_accept() returns true (nonzero) if
 * the header object is an instance of header accept and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_accept(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_accept_hash;
}
#else
int sip_is_accept(sip_header_t const *header);
#endif

#define sip_accept_p(h) sip_is_accept((h))


/**Duplicate (deep copy) @c sip_accept_t.
 * 
 * The function sip_accept_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   accept = sip_accept_dup(home, sip->sip_accept);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_dup() returns a pointer to the
 * newly duplicated sip_accept_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_t *sip_accept_dup(su_home_t *home, sip_accept_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_t *sip_accept_dup(su_home_t *home, sip_accept_t const *hdr)
{ 
  return (sip_accept_t *)
    msg_header_dup_as(home, sip_accept_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_accept_t header structure.
 * 
 * The function sip_accept_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   accept = sip_accept_copy(home, sip->sip_accept);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_t *sip_accept_copy(su_home_t *home, sip_accept_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_t *sip_accept_copy(su_home_t *home, sip_accept_t const *hdr) 
{ 
  return (sip_accept_t *)
    msg_header_copy_as(home, sip_accept_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_accept_t.
 * 
 * The function sip_accept_make() makes a new
 * sip_accept_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_accept_make() returns a pointer to
 * newly maked sip_accept_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_accept_t *sip_accept_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_accept_t *sip_accept_make(su_home_t *home, char const *s)
{
  return (sip_accept_t *)sip_header_make(home, sip_accept_class, s);
}
#endif

/**Make a Accept header from formatting result.
 * 
 * The function sip_accept_format() makes a new
 * Accept header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_accept_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_t *sip_accept_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_accept_t *sip_accept_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_accept_class, fmt, ap);
  va_end(ap);
 
  return (sip_accept_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_accept_encoding
 * @{
 */

/** Parse a Accept-Encoding header. @internal */
SOFIAPUBFUN int sip_accept_encoding_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Accept-Encoding header. @internal */
SOFIAPUBFUN int sip_accept_encoding_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_accept_encoding_t from sip_t.
 * 
 */
#define sip_accept_encoding(sip) \
  ((sip_accept_encoding_t *)msg_header_access((msg_pub_t*)(sip), sip_accept_encoding_class))

/**Initializer for structure sip_accept_encoding_t.
 * 
 * A static sip_accept_encoding_t structure must be initialized.
 * The SIP_ACCEPT_ENCODING_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_accept_encoding_t sip_accept_encoding = SIP_ACCEPT_ENCODING_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ACCEPT_ENCODING_INIT() SIP_HDR_INIT(accept_encoding)

/**Initialize a structure sip_accept_encoding_t.
 * 
 * An sip_accept_encoding_t structure can be initialized with the
 * sip_accept_encoding_init() function/macro. For instance,
 * @code
 * 
 *  sip_accept_encoding_t sip_accept_encoding;
 * 
 *  sip_accept_encoding_init(&sip_accept_encoding);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_accept_encoding_t *sip_accept_encoding_init(sip_accept_encoding_t x[1])
{
  return SIP_HEADER_INIT(x, sip_accept_encoding_class, sizeof(sip_accept_encoding_t));
}
#else
#define sip_accept_encoding_init(x) \
  SIP_HEADER_INIT(x, sip_accept_encoding_class, sizeof(sip_accept_encoding_t))
#endif

/**Test if header object is instance of sip_accept_encoding_t.
 * 
 * The function sip_is_accept_encoding() returns true (nonzero) if
 * the header class is an instance of Accept-Encoding header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_accept_encoding() returns true (nonzero) if
 * the header object is an instance of header accept_encoding and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_accept_encoding(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_accept_encoding_hash;
}
#else
int sip_is_accept_encoding(sip_header_t const *header);
#endif

#define sip_accept_encoding_p(h) sip_is_accept_encoding((h))


/**Duplicate (deep copy) @c sip_accept_encoding_t.
 * 
 * The function sip_accept_encoding_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   accept_encoding = sip_accept_encoding_dup(home, sip->sip_accept_encoding);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_encoding_dup() returns a pointer to the
 * newly duplicated sip_accept_encoding_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_encoding_t *sip_accept_encoding_dup(su_home_t *home, sip_accept_encoding_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_encoding_t *sip_accept_encoding_dup(su_home_t *home, sip_accept_encoding_t const *hdr)
{ 
  return (sip_accept_encoding_t *)
    msg_header_dup_as(home, sip_accept_encoding_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_accept_encoding_t header structure.
 * 
 * The function sip_accept_encoding_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   accept_encoding = sip_accept_encoding_copy(home, sip->sip_accept_encoding);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_encoding_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_encoding_t *sip_accept_encoding_copy(su_home_t *home, sip_accept_encoding_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_encoding_t *sip_accept_encoding_copy(su_home_t *home, sip_accept_encoding_t const *hdr) 
{ 
  return (sip_accept_encoding_t *)
    msg_header_copy_as(home, sip_accept_encoding_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_accept_encoding_t.
 * 
 * The function sip_accept_encoding_make() makes a new
 * sip_accept_encoding_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_accept_encoding_make() returns a pointer to
 * newly maked sip_accept_encoding_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_accept_encoding_t *sip_accept_encoding_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_accept_encoding_t *sip_accept_encoding_make(su_home_t *home, char const *s)
{
  return (sip_accept_encoding_t *)sip_header_make(home, sip_accept_encoding_class, s);
}
#endif

/**Make a Accept-Encoding header from formatting result.
 * 
 * The function sip_accept_encoding_format() makes a new
 * Accept-Encoding header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_accept_encoding_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_encoding_t *sip_accept_encoding_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_accept_encoding_t *sip_accept_encoding_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_accept_encoding_class, fmt, ap);
  va_end(ap);
 
  return (sip_accept_encoding_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_accept_language
 * @{
 */

/** Parse a Accept-Language header. @internal */
SOFIAPUBFUN int sip_accept_language_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Accept-Language header. @internal */
SOFIAPUBFUN int sip_accept_language_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_accept_language_t from sip_t.
 * 
 */
#define sip_accept_language(sip) \
  ((sip_accept_language_t *)msg_header_access((msg_pub_t*)(sip), sip_accept_language_class))

/**Initializer for structure sip_accept_language_t.
 * 
 * A static sip_accept_language_t structure must be initialized.
 * The SIP_ACCEPT_LANGUAGE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_accept_language_t sip_accept_language = SIP_ACCEPT_LANGUAGE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ACCEPT_LANGUAGE_INIT() SIP_HDR_INIT(accept_language)

/**Initialize a structure sip_accept_language_t.
 * 
 * An sip_accept_language_t structure can be initialized with the
 * sip_accept_language_init() function/macro. For instance,
 * @code
 * 
 *  sip_accept_language_t sip_accept_language;
 * 
 *  sip_accept_language_init(&sip_accept_language);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_accept_language_t *sip_accept_language_init(sip_accept_language_t x[1])
{
  return SIP_HEADER_INIT(x, sip_accept_language_class, sizeof(sip_accept_language_t));
}
#else
#define sip_accept_language_init(x) \
  SIP_HEADER_INIT(x, sip_accept_language_class, sizeof(sip_accept_language_t))
#endif

/**Test if header object is instance of sip_accept_language_t.
 * 
 * The function sip_is_accept_language() returns true (nonzero) if
 * the header class is an instance of Accept-Language header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_accept_language() returns true (nonzero) if
 * the header object is an instance of header accept_language and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_accept_language(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_accept_language_hash;
}
#else
int sip_is_accept_language(sip_header_t const *header);
#endif

#define sip_accept_language_p(h) sip_is_accept_language((h))


/**Duplicate (deep copy) @c sip_accept_language_t.
 * 
 * The function sip_accept_language_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   accept_language = sip_accept_language_dup(home, sip->sip_accept_language);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_language_dup() returns a pointer to the
 * newly duplicated sip_accept_language_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_language_t *sip_accept_language_dup(su_home_t *home, sip_accept_language_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_language_t *sip_accept_language_dup(su_home_t *home, sip_accept_language_t const *hdr)
{ 
  return (sip_accept_language_t *)
    msg_header_dup_as(home, sip_accept_language_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_accept_language_t header structure.
 * 
 * The function sip_accept_language_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   accept_language = sip_accept_language_copy(home, sip->sip_accept_language);
 * 
 * @endcode
 * 
 * @return
 * The function sip_accept_language_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_language_t *sip_accept_language_copy(su_home_t *home, sip_accept_language_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_accept_language_t *sip_accept_language_copy(su_home_t *home, sip_accept_language_t const *hdr) 
{ 
  return (sip_accept_language_t *)
    msg_header_copy_as(home, sip_accept_language_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_accept_language_t.
 * 
 * The function sip_accept_language_make() makes a new
 * sip_accept_language_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_accept_language_make() returns a pointer to
 * newly maked sip_accept_language_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_accept_language_t *sip_accept_language_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_accept_language_t *sip_accept_language_make(su_home_t *home, char const *s)
{
  return (sip_accept_language_t *)sip_header_make(home, sip_accept_language_class, s);
}
#endif

/**Make a Accept-Language header from formatting result.
 * 
 * The function sip_accept_language_format() makes a new
 * Accept-Language header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_accept_language_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_accept_language_t *sip_accept_language_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_accept_language_t *sip_accept_language_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_accept_language_class, fmt, ap);
  va_end(ap);
 
  return (sip_accept_language_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_allow
 * @{
 */

/** Parse a Allow header. @internal */
SOFIAPUBFUN int sip_allow_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Allow header. @internal */
SOFIAPUBFUN int sip_allow_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_allow_t from sip_t.
 * 
 */
#define sip_allow(sip) \
  ((sip_allow_t *)msg_header_access((msg_pub_t*)(sip), sip_allow_class))

/**Initializer for structure sip_allow_t.
 * 
 * A static sip_allow_t structure must be initialized.
 * The SIP_ALLOW_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_allow_t sip_allow = SIP_ALLOW_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ALLOW_INIT() SIP_HDR_INIT(allow)

/**Initialize a structure sip_allow_t.
 * 
 * An sip_allow_t structure can be initialized with the
 * sip_allow_init() function/macro. For instance,
 * @code
 * 
 *  sip_allow_t sip_allow;
 * 
 *  sip_allow_init(&sip_allow);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_allow_t *sip_allow_init(sip_allow_t x[1])
{
  return SIP_HEADER_INIT(x, sip_allow_class, sizeof(sip_allow_t));
}
#else
#define sip_allow_init(x) \
  SIP_HEADER_INIT(x, sip_allow_class, sizeof(sip_allow_t))
#endif

/**Test if header object is instance of sip_allow_t.
 * 
 * The function sip_is_allow() returns true (nonzero) if
 * the header class is an instance of Allow header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_allow() returns true (nonzero) if
 * the header object is an instance of header allow and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_allow(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_allow_hash;
}
#else
int sip_is_allow(sip_header_t const *header);
#endif

#define sip_allow_p(h) sip_is_allow((h))


/**Duplicate (deep copy) @c sip_allow_t.
 * 
 * The function sip_allow_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   allow = sip_allow_dup(home, sip->sip_allow);
 * 
 * @endcode
 * 
 * @return
 * The function sip_allow_dup() returns a pointer to the
 * newly duplicated sip_allow_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_allow_t *sip_allow_dup(su_home_t *home, sip_allow_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_allow_t *sip_allow_dup(su_home_t *home, sip_allow_t const *hdr)
{ 
  return (sip_allow_t *)
    msg_header_dup_as(home, sip_allow_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_allow_t header structure.
 * 
 * The function sip_allow_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   allow = sip_allow_copy(home, sip->sip_allow);
 * 
 * @endcode
 * 
 * @return
 * The function sip_allow_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_allow_t *sip_allow_copy(su_home_t *home, sip_allow_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_allow_t *sip_allow_copy(su_home_t *home, sip_allow_t const *hdr) 
{ 
  return (sip_allow_t *)
    msg_header_copy_as(home, sip_allow_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_allow_t.
 * 
 * The function sip_allow_make() makes a new
 * sip_allow_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_allow_make() returns a pointer to
 * newly maked sip_allow_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_allow_t *sip_allow_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_allow_t *sip_allow_make(su_home_t *home, char const *s)
{
  return (sip_allow_t *)sip_header_make(home, sip_allow_class, s);
}
#endif

/**Make a Allow header from formatting result.
 * 
 * The function sip_allow_format() makes a new
 * Allow header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_allow_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_allow_t *sip_allow_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_allow_t *sip_allow_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_allow_class, fmt, ap);
  va_end(ap);
 
  return (sip_allow_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_require
 * @{
 */

/** Parse a Require header. @internal */
SOFIAPUBFUN int sip_require_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Require header. @internal */
SOFIAPUBFUN int sip_require_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_require_t from sip_t.
 * 
 */
#define sip_require(sip) \
  ((sip_require_t *)msg_header_access((msg_pub_t*)(sip), sip_require_class))

/**Initializer for structure sip_require_t.
 * 
 * A static sip_require_t structure must be initialized.
 * The SIP_REQUIRE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_require_t sip_require = SIP_REQUIRE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REQUIRE_INIT() SIP_HDR_INIT(require)

/**Initialize a structure sip_require_t.
 * 
 * An sip_require_t structure can be initialized with the
 * sip_require_init() function/macro. For instance,
 * @code
 * 
 *  sip_require_t sip_require;
 * 
 *  sip_require_init(&sip_require);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_require_t *sip_require_init(sip_require_t x[1])
{
  return SIP_HEADER_INIT(x, sip_require_class, sizeof(sip_require_t));
}
#else
#define sip_require_init(x) \
  SIP_HEADER_INIT(x, sip_require_class, sizeof(sip_require_t))
#endif

/**Test if header object is instance of sip_require_t.
 * 
 * The function sip_is_require() returns true (nonzero) if
 * the header class is an instance of Require header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_require() returns true (nonzero) if
 * the header object is an instance of header require and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_require(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_require_hash;
}
#else
int sip_is_require(sip_header_t const *header);
#endif

#define sip_require_p(h) sip_is_require((h))


/**Duplicate (deep copy) @c sip_require_t.
 * 
 * The function sip_require_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   require = sip_require_dup(home, sip->sip_require);
 * 
 * @endcode
 * 
 * @return
 * The function sip_require_dup() returns a pointer to the
 * newly duplicated sip_require_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_require_t *sip_require_dup(su_home_t *home, sip_require_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_require_t *sip_require_dup(su_home_t *home, sip_require_t const *hdr)
{ 
  return (sip_require_t *)
    msg_header_dup_as(home, sip_require_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_require_t header structure.
 * 
 * The function sip_require_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   require = sip_require_copy(home, sip->sip_require);
 * 
 * @endcode
 * 
 * @return
 * The function sip_require_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_require_t *sip_require_copy(su_home_t *home, sip_require_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_require_t *sip_require_copy(su_home_t *home, sip_require_t const *hdr) 
{ 
  return (sip_require_t *)
    msg_header_copy_as(home, sip_require_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_require_t.
 * 
 * The function sip_require_make() makes a new
 * sip_require_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_require_make() returns a pointer to
 * newly maked sip_require_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_require_t *sip_require_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_require_t *sip_require_make(su_home_t *home, char const *s)
{
  return (sip_require_t *)sip_header_make(home, sip_require_class, s);
}
#endif

/**Make a Require header from formatting result.
 * 
 * The function sip_require_format() makes a new
 * Require header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_require_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_require_t *sip_require_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_require_t *sip_require_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_require_class, fmt, ap);
  va_end(ap);
 
  return (sip_require_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_supported
 * @{
 */

/** Parse a Supported header. @internal */
SOFIAPUBFUN int sip_supported_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Supported header. @internal */
SOFIAPUBFUN int sip_supported_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_supported_t from sip_t.
 * 
 */
#define sip_supported(sip) \
  ((sip_supported_t *)msg_header_access((msg_pub_t*)(sip), sip_supported_class))

/**Initializer for structure sip_supported_t.
 * 
 * A static sip_supported_t structure must be initialized.
 * The SIP_SUPPORTED_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_supported_t sip_supported = SIP_SUPPORTED_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SUPPORTED_INIT() SIP_HDR_INIT(supported)

/**Initialize a structure sip_supported_t.
 * 
 * An sip_supported_t structure can be initialized with the
 * sip_supported_init() function/macro. For instance,
 * @code
 * 
 *  sip_supported_t sip_supported;
 * 
 *  sip_supported_init(&sip_supported);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_supported_t *sip_supported_init(sip_supported_t x[1])
{
  return SIP_HEADER_INIT(x, sip_supported_class, sizeof(sip_supported_t));
}
#else
#define sip_supported_init(x) \
  SIP_HEADER_INIT(x, sip_supported_class, sizeof(sip_supported_t))
#endif

/**Test if header object is instance of sip_supported_t.
 * 
 * The function sip_is_supported() returns true (nonzero) if
 * the header class is an instance of Supported header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_supported() returns true (nonzero) if
 * the header object is an instance of header supported and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_supported(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_supported_hash;
}
#else
int sip_is_supported(sip_header_t const *header);
#endif

#define sip_supported_p(h) sip_is_supported((h))


/**Duplicate (deep copy) @c sip_supported_t.
 * 
 * The function sip_supported_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   supported = sip_supported_dup(home, sip->sip_supported);
 * 
 * @endcode
 * 
 * @return
 * The function sip_supported_dup() returns a pointer to the
 * newly duplicated sip_supported_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_supported_t *sip_supported_dup(su_home_t *home, sip_supported_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_supported_t *sip_supported_dup(su_home_t *home, sip_supported_t const *hdr)
{ 
  return (sip_supported_t *)
    msg_header_dup_as(home, sip_supported_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_supported_t header structure.
 * 
 * The function sip_supported_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   supported = sip_supported_copy(home, sip->sip_supported);
 * 
 * @endcode
 * 
 * @return
 * The function sip_supported_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_supported_t *sip_supported_copy(su_home_t *home, sip_supported_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_supported_t *sip_supported_copy(su_home_t *home, sip_supported_t const *hdr) 
{ 
  return (sip_supported_t *)
    msg_header_copy_as(home, sip_supported_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_supported_t.
 * 
 * The function sip_supported_make() makes a new
 * sip_supported_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_supported_make() returns a pointer to
 * newly maked sip_supported_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_supported_t *sip_supported_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_supported_t *sip_supported_make(su_home_t *home, char const *s)
{
  return (sip_supported_t *)sip_header_make(home, sip_supported_class, s);
}
#endif

/**Make a Supported header from formatting result.
 * 
 * The function sip_supported_format() makes a new
 * Supported header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_supported_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_supported_t *sip_supported_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_supported_t *sip_supported_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_supported_class, fmt, ap);
  va_end(ap);
 
  return (sip_supported_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_unsupported
 * @{
 */

/** Parse a Unsupported header. @internal */
SOFIAPUBFUN int sip_unsupported_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Unsupported header. @internal */
SOFIAPUBFUN int sip_unsupported_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_unsupported_t from sip_t.
 * 
 */
#define sip_unsupported(sip) \
  ((sip_unsupported_t *)msg_header_access((msg_pub_t*)(sip), sip_unsupported_class))

/**Initializer for structure sip_unsupported_t.
 * 
 * A static sip_unsupported_t structure must be initialized.
 * The SIP_UNSUPPORTED_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_unsupported_t sip_unsupported = SIP_UNSUPPORTED_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_UNSUPPORTED_INIT() SIP_HDR_INIT(unsupported)

/**Initialize a structure sip_unsupported_t.
 * 
 * An sip_unsupported_t structure can be initialized with the
 * sip_unsupported_init() function/macro. For instance,
 * @code
 * 
 *  sip_unsupported_t sip_unsupported;
 * 
 *  sip_unsupported_init(&sip_unsupported);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_unsupported_t *sip_unsupported_init(sip_unsupported_t x[1])
{
  return SIP_HEADER_INIT(x, sip_unsupported_class, sizeof(sip_unsupported_t));
}
#else
#define sip_unsupported_init(x) \
  SIP_HEADER_INIT(x, sip_unsupported_class, sizeof(sip_unsupported_t))
#endif

/**Test if header object is instance of sip_unsupported_t.
 * 
 * The function sip_is_unsupported() returns true (nonzero) if
 * the header class is an instance of Unsupported header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_unsupported() returns true (nonzero) if
 * the header object is an instance of header unsupported and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_unsupported(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_unsupported_hash;
}
#else
int sip_is_unsupported(sip_header_t const *header);
#endif

#define sip_unsupported_p(h) sip_is_unsupported((h))


/**Duplicate (deep copy) @c sip_unsupported_t.
 * 
 * The function sip_unsupported_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   unsupported = sip_unsupported_dup(home, sip->sip_unsupported);
 * 
 * @endcode
 * 
 * @return
 * The function sip_unsupported_dup() returns a pointer to the
 * newly duplicated sip_unsupported_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_unsupported_t *sip_unsupported_dup(su_home_t *home, sip_unsupported_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_unsupported_t *sip_unsupported_dup(su_home_t *home, sip_unsupported_t const *hdr)
{ 
  return (sip_unsupported_t *)
    msg_header_dup_as(home, sip_unsupported_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_unsupported_t header structure.
 * 
 * The function sip_unsupported_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   unsupported = sip_unsupported_copy(home, sip->sip_unsupported);
 * 
 * @endcode
 * 
 * @return
 * The function sip_unsupported_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_unsupported_t *sip_unsupported_copy(su_home_t *home, sip_unsupported_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_unsupported_t *sip_unsupported_copy(su_home_t *home, sip_unsupported_t const *hdr) 
{ 
  return (sip_unsupported_t *)
    msg_header_copy_as(home, sip_unsupported_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_unsupported_t.
 * 
 * The function sip_unsupported_make() makes a new
 * sip_unsupported_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_unsupported_make() returns a pointer to
 * newly maked sip_unsupported_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_unsupported_t *sip_unsupported_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_unsupported_t *sip_unsupported_make(su_home_t *home, char const *s)
{
  return (sip_unsupported_t *)sip_header_make(home, sip_unsupported_class, s);
}
#endif

/**Make a Unsupported header from formatting result.
 * 
 * The function sip_unsupported_format() makes a new
 * Unsupported header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_unsupported_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_unsupported_t *sip_unsupported_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_unsupported_t *sip_unsupported_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_unsupported_class, fmt, ap);
  va_end(ap);
 
  return (sip_unsupported_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_event
 * @{
 */

/** Parse a Event header. @internal */
SOFIAPUBFUN int sip_event_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Event header. @internal */
SOFIAPUBFUN int sip_event_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_event_t from sip_t.
 * 
 */
#define sip_event(sip) \
  ((sip_event_t *)msg_header_access((msg_pub_t*)(sip), sip_event_class))

/**Initializer for structure sip_event_t.
 * 
 * A static sip_event_t structure must be initialized.
 * The SIP_EVENT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_event_t sip_event = SIP_EVENT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_EVENT_INIT() SIP_HDR_INIT(event)

/**Initialize a structure sip_event_t.
 * 
 * An sip_event_t structure can be initialized with the
 * sip_event_init() function/macro. For instance,
 * @code
 * 
 *  sip_event_t sip_event;
 * 
 *  sip_event_init(&sip_event);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_event_t *sip_event_init(sip_event_t x[1])
{
  return SIP_HEADER_INIT(x, sip_event_class, sizeof(sip_event_t));
}
#else
#define sip_event_init(x) \
  SIP_HEADER_INIT(x, sip_event_class, sizeof(sip_event_t))
#endif

/**Test if header object is instance of sip_event_t.
 * 
 * The function sip_is_event() returns true (nonzero) if
 * the header class is an instance of Event header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_event() returns true (nonzero) if
 * the header object is an instance of header event and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_event(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_event_hash;
}
#else
int sip_is_event(sip_header_t const *header);
#endif

#define sip_event_p(h) sip_is_event((h))


/**Duplicate (deep copy) @c sip_event_t.
 * 
 * The function sip_event_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   event = sip_event_dup(home, sip->sip_event);
 * 
 * @endcode
 * 
 * @return
 * The function sip_event_dup() returns a pointer to the
 * newly duplicated sip_event_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_event_t *sip_event_dup(su_home_t *home, sip_event_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_event_t *sip_event_dup(su_home_t *home, sip_event_t const *hdr)
{ 
  return (sip_event_t *)
    msg_header_dup_as(home, sip_event_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_event_t header structure.
 * 
 * The function sip_event_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   event = sip_event_copy(home, sip->sip_event);
 * 
 * @endcode
 * 
 * @return
 * The function sip_event_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_event_t *sip_event_copy(su_home_t *home, sip_event_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_event_t *sip_event_copy(su_home_t *home, sip_event_t const *hdr) 
{ 
  return (sip_event_t *)
    msg_header_copy_as(home, sip_event_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_event_t.
 * 
 * The function sip_event_make() makes a new
 * sip_event_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_event_make() returns a pointer to
 * newly maked sip_event_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_event_t *sip_event_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_event_t *sip_event_make(su_home_t *home, char const *s)
{
  return (sip_event_t *)sip_header_make(home, sip_event_class, s);
}
#endif

/**Make a Event header from formatting result.
 * 
 * The function sip_event_format() makes a new
 * Event header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_event_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_event_t *sip_event_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_event_t *sip_event_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_event_class, fmt, ap);
  va_end(ap);
 
  return (sip_event_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_allow_events
 * @{
 */

/** Parse a Allow-Events header. @internal */
SOFIAPUBFUN int sip_allow_events_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Allow-Events header. @internal */
SOFIAPUBFUN int sip_allow_events_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_allow_events_t from sip_t.
 * 
 */
#define sip_allow_events(sip) \
  ((sip_allow_events_t *)msg_header_access((msg_pub_t*)(sip), sip_allow_events_class))

/**Initializer for structure sip_allow_events_t.
 * 
 * A static sip_allow_events_t structure must be initialized.
 * The SIP_ALLOW_EVENTS_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_allow_events_t sip_allow_events = SIP_ALLOW_EVENTS_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ALLOW_EVENTS_INIT() SIP_HDR_INIT(allow_events)

/**Initialize a structure sip_allow_events_t.
 * 
 * An sip_allow_events_t structure can be initialized with the
 * sip_allow_events_init() function/macro. For instance,
 * @code
 * 
 *  sip_allow_events_t sip_allow_events;
 * 
 *  sip_allow_events_init(&sip_allow_events);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_allow_events_t *sip_allow_events_init(sip_allow_events_t x[1])
{
  return SIP_HEADER_INIT(x, sip_allow_events_class, sizeof(sip_allow_events_t));
}
#else
#define sip_allow_events_init(x) \
  SIP_HEADER_INIT(x, sip_allow_events_class, sizeof(sip_allow_events_t))
#endif

/**Test if header object is instance of sip_allow_events_t.
 * 
 * The function sip_is_allow_events() returns true (nonzero) if
 * the header class is an instance of Allow-Events header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_allow_events() returns true (nonzero) if
 * the header object is an instance of header allow_events and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_allow_events(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_allow_events_hash;
}
#else
int sip_is_allow_events(sip_header_t const *header);
#endif

#define sip_allow_events_p(h) sip_is_allow_events((h))


/**Duplicate (deep copy) @c sip_allow_events_t.
 * 
 * The function sip_allow_events_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   allow_events = sip_allow_events_dup(home, sip->sip_allow_events);
 * 
 * @endcode
 * 
 * @return
 * The function sip_allow_events_dup() returns a pointer to the
 * newly duplicated sip_allow_events_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_allow_events_t *sip_allow_events_dup(su_home_t *home, sip_allow_events_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_allow_events_t *sip_allow_events_dup(su_home_t *home, sip_allow_events_t const *hdr)
{ 
  return (sip_allow_events_t *)
    msg_header_dup_as(home, sip_allow_events_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_allow_events_t header structure.
 * 
 * The function sip_allow_events_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   allow_events = sip_allow_events_copy(home, sip->sip_allow_events);
 * 
 * @endcode
 * 
 * @return
 * The function sip_allow_events_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_allow_events_t *sip_allow_events_copy(su_home_t *home, sip_allow_events_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_allow_events_t *sip_allow_events_copy(su_home_t *home, sip_allow_events_t const *hdr) 
{ 
  return (sip_allow_events_t *)
    msg_header_copy_as(home, sip_allow_events_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_allow_events_t.
 * 
 * The function sip_allow_events_make() makes a new
 * sip_allow_events_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_allow_events_make() returns a pointer to
 * newly maked sip_allow_events_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_allow_events_t *sip_allow_events_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_allow_events_t *sip_allow_events_make(su_home_t *home, char const *s)
{
  return (sip_allow_events_t *)sip_header_make(home, sip_allow_events_class, s);
}
#endif

/**Make a Allow-Events header from formatting result.
 * 
 * The function sip_allow_events_format() makes a new
 * Allow-Events header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_allow_events_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_allow_events_t *sip_allow_events_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_allow_events_t *sip_allow_events_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_allow_events_class, fmt, ap);
  va_end(ap);
 
  return (sip_allow_events_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_subscription_state
 * @{
 */

/** Parse a Subscription-State header. @internal */
SOFIAPUBFUN int sip_subscription_state_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Subscription-State header. @internal */
SOFIAPUBFUN int sip_subscription_state_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_subscription_state_t from sip_t.
 * 
 */
#define sip_subscription_state(sip) \
  ((sip_subscription_state_t *)msg_header_access((msg_pub_t*)(sip), sip_subscription_state_class))

/**Initializer for structure sip_subscription_state_t.
 * 
 * A static sip_subscription_state_t structure must be initialized.
 * The SIP_SUBSCRIPTION_STATE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_subscription_state_t sip_subscription_state = SIP_SUBSCRIPTION_STATE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SUBSCRIPTION_STATE_INIT() SIP_HDR_INIT(subscription_state)

/**Initialize a structure sip_subscription_state_t.
 * 
 * An sip_subscription_state_t structure can be initialized with the
 * sip_subscription_state_init() function/macro. For instance,
 * @code
 * 
 *  sip_subscription_state_t sip_subscription_state;
 * 
 *  sip_subscription_state_init(&sip_subscription_state);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_subscription_state_t *sip_subscription_state_init(sip_subscription_state_t x[1])
{
  return SIP_HEADER_INIT(x, sip_subscription_state_class, sizeof(sip_subscription_state_t));
}
#else
#define sip_subscription_state_init(x) \
  SIP_HEADER_INIT(x, sip_subscription_state_class, sizeof(sip_subscription_state_t))
#endif

/**Test if header object is instance of sip_subscription_state_t.
 * 
 * The function sip_is_subscription_state() returns true (nonzero) if
 * the header class is an instance of Subscription-State header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_subscription_state() returns true (nonzero) if
 * the header object is an instance of header subscription_state and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_subscription_state(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_subscription_state_hash;
}
#else
int sip_is_subscription_state(sip_header_t const *header);
#endif

#define sip_subscription_state_p(h) sip_is_subscription_state((h))


/**Duplicate (deep copy) @c sip_subscription_state_t.
 * 
 * The function sip_subscription_state_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   subscription_state = sip_subscription_state_dup(home, sip->sip_subscription_state);
 * 
 * @endcode
 * 
 * @return
 * The function sip_subscription_state_dup() returns a pointer to the
 * newly duplicated sip_subscription_state_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_subscription_state_t *sip_subscription_state_dup(su_home_t *home, sip_subscription_state_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_subscription_state_t *sip_subscription_state_dup(su_home_t *home, sip_subscription_state_t const *hdr)
{ 
  return (sip_subscription_state_t *)
    msg_header_dup_as(home, sip_subscription_state_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_subscription_state_t header structure.
 * 
 * The function sip_subscription_state_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   subscription_state = sip_subscription_state_copy(home, sip->sip_subscription_state);
 * 
 * @endcode
 * 
 * @return
 * The function sip_subscription_state_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_subscription_state_t *sip_subscription_state_copy(su_home_t *home, sip_subscription_state_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_subscription_state_t *sip_subscription_state_copy(su_home_t *home, sip_subscription_state_t const *hdr) 
{ 
  return (sip_subscription_state_t *)
    msg_header_copy_as(home, sip_subscription_state_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_subscription_state_t.
 * 
 * The function sip_subscription_state_make() makes a new
 * sip_subscription_state_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_subscription_state_make() returns a pointer to
 * newly maked sip_subscription_state_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_subscription_state_t *sip_subscription_state_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_subscription_state_t *sip_subscription_state_make(su_home_t *home, char const *s)
{
  return (sip_subscription_state_t *)sip_header_make(home, sip_subscription_state_class, s);
}
#endif

/**Make a Subscription-State header from formatting result.
 * 
 * The function sip_subscription_state_format() makes a new
 * Subscription-State header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_subscription_state_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_subscription_state_t *sip_subscription_state_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_subscription_state_t *sip_subscription_state_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_subscription_state_class, fmt, ap);
  va_end(ap);
 
  return (sip_subscription_state_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_proxy_authenticate
 * @{
 */

/** Parse a Proxy-Authenticate header. @internal */
SOFIAPUBFUN int sip_proxy_authenticate_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Proxy-Authenticate header. @internal */
SOFIAPUBFUN int sip_proxy_authenticate_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_proxy_authenticate_t from sip_t.
 * 
 */
#define sip_proxy_authenticate(sip) \
  ((sip_proxy_authenticate_t *)msg_header_access((msg_pub_t*)(sip), sip_proxy_authenticate_class))

/**Initializer for structure sip_proxy_authenticate_t.
 * 
 * A static sip_proxy_authenticate_t structure must be initialized.
 * The SIP_PROXY_AUTHENTICATE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_proxy_authenticate_t sip_proxy_authenticate = SIP_PROXY_AUTHENTICATE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PROXY_AUTHENTICATE_INIT() SIP_HDR_INIT(proxy_authenticate)

/**Initialize a structure sip_proxy_authenticate_t.
 * 
 * An sip_proxy_authenticate_t structure can be initialized with the
 * sip_proxy_authenticate_init() function/macro. For instance,
 * @code
 * 
 *  sip_proxy_authenticate_t sip_proxy_authenticate;
 * 
 *  sip_proxy_authenticate_init(&sip_proxy_authenticate);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_proxy_authenticate_t *sip_proxy_authenticate_init(sip_proxy_authenticate_t x[1])
{
  return SIP_HEADER_INIT(x, sip_proxy_authenticate_class, sizeof(sip_proxy_authenticate_t));
}
#else
#define sip_proxy_authenticate_init(x) \
  SIP_HEADER_INIT(x, sip_proxy_authenticate_class, sizeof(sip_proxy_authenticate_t))
#endif

/**Test if header object is instance of sip_proxy_authenticate_t.
 * 
 * The function sip_is_proxy_authenticate() returns true (nonzero) if
 * the header class is an instance of Proxy-Authenticate header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_proxy_authenticate() returns true (nonzero) if
 * the header object is an instance of header proxy_authenticate and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_proxy_authenticate(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_proxy_authenticate_hash;
}
#else
int sip_is_proxy_authenticate(sip_header_t const *header);
#endif

#define sip_proxy_authenticate_p(h) sip_is_proxy_authenticate((h))


/**Duplicate (deep copy) @c sip_proxy_authenticate_t.
 * 
 * The function sip_proxy_authenticate_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   proxy_authenticate = sip_proxy_authenticate_dup(home, sip->sip_proxy_authenticate);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_authenticate_dup() returns a pointer to the
 * newly duplicated sip_proxy_authenticate_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authenticate_t *sip_proxy_authenticate_dup(su_home_t *home, sip_proxy_authenticate_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_authenticate_t *sip_proxy_authenticate_dup(su_home_t *home, sip_proxy_authenticate_t const *hdr)
{ 
  return (sip_proxy_authenticate_t *)
    msg_header_dup_as(home, sip_proxy_authenticate_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_proxy_authenticate_t header structure.
 * 
 * The function sip_proxy_authenticate_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   proxy_authenticate = sip_proxy_authenticate_copy(home, sip->sip_proxy_authenticate);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_authenticate_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authenticate_t *sip_proxy_authenticate_copy(su_home_t *home, sip_proxy_authenticate_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_authenticate_t *sip_proxy_authenticate_copy(su_home_t *home, sip_proxy_authenticate_t const *hdr) 
{ 
  return (sip_proxy_authenticate_t *)
    msg_header_copy_as(home, sip_proxy_authenticate_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_proxy_authenticate_t.
 * 
 * The function sip_proxy_authenticate_make() makes a new
 * sip_proxy_authenticate_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_proxy_authenticate_make() returns a pointer to
 * newly maked sip_proxy_authenticate_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_proxy_authenticate_t *sip_proxy_authenticate_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_proxy_authenticate_t *sip_proxy_authenticate_make(su_home_t *home, char const *s)
{
  return (sip_proxy_authenticate_t *)sip_header_make(home, sip_proxy_authenticate_class, s);
}
#endif

/**Make a Proxy-Authenticate header from formatting result.
 * 
 * The function sip_proxy_authenticate_format() makes a new
 * Proxy-Authenticate header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_proxy_authenticate_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authenticate_t *sip_proxy_authenticate_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_proxy_authenticate_t *sip_proxy_authenticate_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_proxy_authenticate_class, fmt, ap);
  va_end(ap);
 
  return (sip_proxy_authenticate_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_proxy_authentication_info
 * @{
 */

/** Parse a Proxy-Authentication-Info header. @internal */
SOFIAPUBFUN int sip_proxy_authentication_info_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Proxy-Authentication-Info header. @internal */
SOFIAPUBFUN int sip_proxy_authentication_info_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_proxy_authentication_info_t from sip_t.
 * 
 */
#define sip_proxy_authentication_info(sip) \
  ((sip_proxy_authentication_info_t *)msg_header_access((msg_pub_t*)(sip), sip_proxy_authentication_info_class))

/**Initializer for structure sip_proxy_authentication_info_t.
 * 
 * A static sip_proxy_authentication_info_t structure must be initialized.
 * The SIP_PROXY_AUTHENTICATION_INFO_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_proxy_authentication_info_t sip_proxy_authentication_info = SIP_PROXY_AUTHENTICATION_INFO_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PROXY_AUTHENTICATION_INFO_INIT() SIP_HDR_INIT(proxy_authentication_info)

/**Initialize a structure sip_proxy_authentication_info_t.
 * 
 * An sip_proxy_authentication_info_t structure can be initialized with the
 * sip_proxy_authentication_info_init() function/macro. For instance,
 * @code
 * 
 *  sip_proxy_authentication_info_t sip_proxy_authentication_info;
 * 
 *  sip_proxy_authentication_info_init(&sip_proxy_authentication_info);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_proxy_authentication_info_t *sip_proxy_authentication_info_init(sip_proxy_authentication_info_t x[1])
{
  return SIP_HEADER_INIT(x, sip_proxy_authentication_info_class, sizeof(sip_proxy_authentication_info_t));
}
#else
#define sip_proxy_authentication_info_init(x) \
  SIP_HEADER_INIT(x, sip_proxy_authentication_info_class, sizeof(sip_proxy_authentication_info_t))
#endif

/**Test if header object is instance of sip_proxy_authentication_info_t.
 * 
 * The function sip_is_proxy_authentication_info() returns true (nonzero) if
 * the header class is an instance of Proxy-Authentication-Info header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_proxy_authentication_info() returns true (nonzero) if
 * the header object is an instance of header proxy_authentication_info and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_proxy_authentication_info(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_proxy_authentication_info_hash;
}
#else
int sip_is_proxy_authentication_info(sip_header_t const *header);
#endif

#define sip_proxy_authentication_info_p(h) sip_is_proxy_authentication_info((h))


/**Duplicate (deep copy) @c sip_proxy_authentication_info_t.
 * 
 * The function sip_proxy_authentication_info_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   proxy_authentication_info = sip_proxy_authentication_info_dup(home, sip->sip_proxy_authentication_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_authentication_info_dup() returns a pointer to the
 * newly duplicated sip_proxy_authentication_info_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authentication_info_t *sip_proxy_authentication_info_dup(su_home_t *home, sip_proxy_authentication_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_authentication_info_t *sip_proxy_authentication_info_dup(su_home_t *home, sip_proxy_authentication_info_t const *hdr)
{ 
  return (sip_proxy_authentication_info_t *)
    msg_header_dup_as(home, sip_proxy_authentication_info_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_proxy_authentication_info_t header structure.
 * 
 * The function sip_proxy_authentication_info_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   proxy_authentication_info = sip_proxy_authentication_info_copy(home, sip->sip_proxy_authentication_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_authentication_info_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authentication_info_t *sip_proxy_authentication_info_copy(su_home_t *home, sip_proxy_authentication_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_authentication_info_t *sip_proxy_authentication_info_copy(su_home_t *home, sip_proxy_authentication_info_t const *hdr) 
{ 
  return (sip_proxy_authentication_info_t *)
    msg_header_copy_as(home, sip_proxy_authentication_info_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_proxy_authentication_info_t.
 * 
 * The function sip_proxy_authentication_info_make() makes a new
 * sip_proxy_authentication_info_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_proxy_authentication_info_make() returns a pointer to
 * newly maked sip_proxy_authentication_info_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_proxy_authentication_info_t *sip_proxy_authentication_info_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_proxy_authentication_info_t *sip_proxy_authentication_info_make(su_home_t *home, char const *s)
{
  return (sip_proxy_authentication_info_t *)sip_header_make(home, sip_proxy_authentication_info_class, s);
}
#endif

/**Make a Proxy-Authentication-Info header from formatting result.
 * 
 * The function sip_proxy_authentication_info_format() makes a new
 * Proxy-Authentication-Info header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_proxy_authentication_info_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authentication_info_t *sip_proxy_authentication_info_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_proxy_authentication_info_t *sip_proxy_authentication_info_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_proxy_authentication_info_class, fmt, ap);
  va_end(ap);
 
  return (sip_proxy_authentication_info_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_proxy_authorization
 * @{
 */

/** Parse a Proxy-Authorization header. @internal */
SOFIAPUBFUN int sip_proxy_authorization_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Proxy-Authorization header. @internal */
SOFIAPUBFUN int sip_proxy_authorization_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_proxy_authorization_t from sip_t.
 * 
 */
#define sip_proxy_authorization(sip) \
  ((sip_proxy_authorization_t *)msg_header_access((msg_pub_t*)(sip), sip_proxy_authorization_class))

/**Initializer for structure sip_proxy_authorization_t.
 * 
 * A static sip_proxy_authorization_t structure must be initialized.
 * The SIP_PROXY_AUTHORIZATION_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_proxy_authorization_t sip_proxy_authorization = SIP_PROXY_AUTHORIZATION_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PROXY_AUTHORIZATION_INIT() SIP_HDR_INIT(proxy_authorization)

/**Initialize a structure sip_proxy_authorization_t.
 * 
 * An sip_proxy_authorization_t structure can be initialized with the
 * sip_proxy_authorization_init() function/macro. For instance,
 * @code
 * 
 *  sip_proxy_authorization_t sip_proxy_authorization;
 * 
 *  sip_proxy_authorization_init(&sip_proxy_authorization);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_proxy_authorization_t *sip_proxy_authorization_init(sip_proxy_authorization_t x[1])
{
  return SIP_HEADER_INIT(x, sip_proxy_authorization_class, sizeof(sip_proxy_authorization_t));
}
#else
#define sip_proxy_authorization_init(x) \
  SIP_HEADER_INIT(x, sip_proxy_authorization_class, sizeof(sip_proxy_authorization_t))
#endif

/**Test if header object is instance of sip_proxy_authorization_t.
 * 
 * The function sip_is_proxy_authorization() returns true (nonzero) if
 * the header class is an instance of Proxy-Authorization header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_proxy_authorization() returns true (nonzero) if
 * the header object is an instance of header proxy_authorization and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_proxy_authorization(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_proxy_authorization_hash;
}
#else
int sip_is_proxy_authorization(sip_header_t const *header);
#endif

#define sip_proxy_authorization_p(h) sip_is_proxy_authorization((h))


/**Duplicate (deep copy) @c sip_proxy_authorization_t.
 * 
 * The function sip_proxy_authorization_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   proxy_authorization = sip_proxy_authorization_dup(home, sip->sip_proxy_authorization);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_authorization_dup() returns a pointer to the
 * newly duplicated sip_proxy_authorization_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authorization_t *sip_proxy_authorization_dup(su_home_t *home, sip_proxy_authorization_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_authorization_t *sip_proxy_authorization_dup(su_home_t *home, sip_proxy_authorization_t const *hdr)
{ 
  return (sip_proxy_authorization_t *)
    msg_header_dup_as(home, sip_proxy_authorization_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_proxy_authorization_t header structure.
 * 
 * The function sip_proxy_authorization_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   proxy_authorization = sip_proxy_authorization_copy(home, sip->sip_proxy_authorization);
 * 
 * @endcode
 * 
 * @return
 * The function sip_proxy_authorization_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authorization_t *sip_proxy_authorization_copy(su_home_t *home, sip_proxy_authorization_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_proxy_authorization_t *sip_proxy_authorization_copy(su_home_t *home, sip_proxy_authorization_t const *hdr) 
{ 
  return (sip_proxy_authorization_t *)
    msg_header_copy_as(home, sip_proxy_authorization_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_proxy_authorization_t.
 * 
 * The function sip_proxy_authorization_make() makes a new
 * sip_proxy_authorization_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_proxy_authorization_make() returns a pointer to
 * newly maked sip_proxy_authorization_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_proxy_authorization_t *sip_proxy_authorization_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_proxy_authorization_t *sip_proxy_authorization_make(su_home_t *home, char const *s)
{
  return (sip_proxy_authorization_t *)sip_header_make(home, sip_proxy_authorization_class, s);
}
#endif

/**Make a Proxy-Authorization header from formatting result.
 * 
 * The function sip_proxy_authorization_format() makes a new
 * Proxy-Authorization header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_proxy_authorization_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_proxy_authorization_t *sip_proxy_authorization_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_proxy_authorization_t *sip_proxy_authorization_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_proxy_authorization_class, fmt, ap);
  va_end(ap);
 
  return (sip_proxy_authorization_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_authorization
 * @{
 */

/** Parse a Authorization header. @internal */
SOFIAPUBFUN int sip_authorization_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Authorization header. @internal */
SOFIAPUBFUN int sip_authorization_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_authorization_t from sip_t.
 * 
 */
#define sip_authorization(sip) \
  ((sip_authorization_t *)msg_header_access((msg_pub_t*)(sip), sip_authorization_class))

/**Initializer for structure sip_authorization_t.
 * 
 * A static sip_authorization_t structure must be initialized.
 * The SIP_AUTHORIZATION_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_authorization_t sip_authorization = SIP_AUTHORIZATION_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_AUTHORIZATION_INIT() SIP_HDR_INIT(authorization)

/**Initialize a structure sip_authorization_t.
 * 
 * An sip_authorization_t structure can be initialized with the
 * sip_authorization_init() function/macro. For instance,
 * @code
 * 
 *  sip_authorization_t sip_authorization;
 * 
 *  sip_authorization_init(&sip_authorization);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_authorization_t *sip_authorization_init(sip_authorization_t x[1])
{
  return SIP_HEADER_INIT(x, sip_authorization_class, sizeof(sip_authorization_t));
}
#else
#define sip_authorization_init(x) \
  SIP_HEADER_INIT(x, sip_authorization_class, sizeof(sip_authorization_t))
#endif

/**Test if header object is instance of sip_authorization_t.
 * 
 * The function sip_is_authorization() returns true (nonzero) if
 * the header class is an instance of Authorization header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_authorization() returns true (nonzero) if
 * the header object is an instance of header authorization and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_authorization(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_authorization_hash;
}
#else
int sip_is_authorization(sip_header_t const *header);
#endif

#define sip_authorization_p(h) sip_is_authorization((h))


/**Duplicate (deep copy) @c sip_authorization_t.
 * 
 * The function sip_authorization_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   authorization = sip_authorization_dup(home, sip->sip_authorization);
 * 
 * @endcode
 * 
 * @return
 * The function sip_authorization_dup() returns a pointer to the
 * newly duplicated sip_authorization_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_authorization_t *sip_authorization_dup(su_home_t *home, sip_authorization_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_authorization_t *sip_authorization_dup(su_home_t *home, sip_authorization_t const *hdr)
{ 
  return (sip_authorization_t *)
    msg_header_dup_as(home, sip_authorization_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_authorization_t header structure.
 * 
 * The function sip_authorization_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   authorization = sip_authorization_copy(home, sip->sip_authorization);
 * 
 * @endcode
 * 
 * @return
 * The function sip_authorization_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_authorization_t *sip_authorization_copy(su_home_t *home, sip_authorization_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_authorization_t *sip_authorization_copy(su_home_t *home, sip_authorization_t const *hdr) 
{ 
  return (sip_authorization_t *)
    msg_header_copy_as(home, sip_authorization_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_authorization_t.
 * 
 * The function sip_authorization_make() makes a new
 * sip_authorization_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_authorization_make() returns a pointer to
 * newly maked sip_authorization_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_authorization_t *sip_authorization_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_authorization_t *sip_authorization_make(su_home_t *home, char const *s)
{
  return (sip_authorization_t *)sip_header_make(home, sip_authorization_class, s);
}
#endif

/**Make a Authorization header from formatting result.
 * 
 * The function sip_authorization_format() makes a new
 * Authorization header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_authorization_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_authorization_t *sip_authorization_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_authorization_t *sip_authorization_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_authorization_class, fmt, ap);
  va_end(ap);
 
  return (sip_authorization_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_www_authenticate
 * @{
 */

/** Parse a WWW-Authenticate header. @internal */
SOFIAPUBFUN int sip_www_authenticate_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a WWW-Authenticate header. @internal */
SOFIAPUBFUN int sip_www_authenticate_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_www_authenticate_t from sip_t.
 * 
 */
#define sip_www_authenticate(sip) \
  ((sip_www_authenticate_t *)msg_header_access((msg_pub_t*)(sip), sip_www_authenticate_class))

/**Initializer for structure sip_www_authenticate_t.
 * 
 * A static sip_www_authenticate_t structure must be initialized.
 * The SIP_WWW_AUTHENTICATE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_www_authenticate_t sip_www_authenticate = SIP_WWW_AUTHENTICATE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_WWW_AUTHENTICATE_INIT() SIP_HDR_INIT(www_authenticate)

/**Initialize a structure sip_www_authenticate_t.
 * 
 * An sip_www_authenticate_t structure can be initialized with the
 * sip_www_authenticate_init() function/macro. For instance,
 * @code
 * 
 *  sip_www_authenticate_t sip_www_authenticate;
 * 
 *  sip_www_authenticate_init(&sip_www_authenticate);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_www_authenticate_t *sip_www_authenticate_init(sip_www_authenticate_t x[1])
{
  return SIP_HEADER_INIT(x, sip_www_authenticate_class, sizeof(sip_www_authenticate_t));
}
#else
#define sip_www_authenticate_init(x) \
  SIP_HEADER_INIT(x, sip_www_authenticate_class, sizeof(sip_www_authenticate_t))
#endif

/**Test if header object is instance of sip_www_authenticate_t.
 * 
 * The function sip_is_www_authenticate() returns true (nonzero) if
 * the header class is an instance of WWW-Authenticate header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_www_authenticate() returns true (nonzero) if
 * the header object is an instance of header www_authenticate and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_www_authenticate(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_www_authenticate_hash;
}
#else
int sip_is_www_authenticate(sip_header_t const *header);
#endif

#define sip_www_authenticate_p(h) sip_is_www_authenticate((h))


/**Duplicate (deep copy) @c sip_www_authenticate_t.
 * 
 * The function sip_www_authenticate_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   www_authenticate = sip_www_authenticate_dup(home, sip->sip_www_authenticate);
 * 
 * @endcode
 * 
 * @return
 * The function sip_www_authenticate_dup() returns a pointer to the
 * newly duplicated sip_www_authenticate_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_www_authenticate_t *sip_www_authenticate_dup(su_home_t *home, sip_www_authenticate_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_www_authenticate_t *sip_www_authenticate_dup(su_home_t *home, sip_www_authenticate_t const *hdr)
{ 
  return (sip_www_authenticate_t *)
    msg_header_dup_as(home, sip_www_authenticate_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_www_authenticate_t header structure.
 * 
 * The function sip_www_authenticate_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   www_authenticate = sip_www_authenticate_copy(home, sip->sip_www_authenticate);
 * 
 * @endcode
 * 
 * @return
 * The function sip_www_authenticate_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_www_authenticate_t *sip_www_authenticate_copy(su_home_t *home, sip_www_authenticate_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_www_authenticate_t *sip_www_authenticate_copy(su_home_t *home, sip_www_authenticate_t const *hdr) 
{ 
  return (sip_www_authenticate_t *)
    msg_header_copy_as(home, sip_www_authenticate_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_www_authenticate_t.
 * 
 * The function sip_www_authenticate_make() makes a new
 * sip_www_authenticate_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_www_authenticate_make() returns a pointer to
 * newly maked sip_www_authenticate_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_www_authenticate_t *sip_www_authenticate_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_www_authenticate_t *sip_www_authenticate_make(su_home_t *home, char const *s)
{
  return (sip_www_authenticate_t *)sip_header_make(home, sip_www_authenticate_class, s);
}
#endif

/**Make a WWW-Authenticate header from formatting result.
 * 
 * The function sip_www_authenticate_format() makes a new
 * WWW-Authenticate header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_www_authenticate_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_www_authenticate_t *sip_www_authenticate_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_www_authenticate_t *sip_www_authenticate_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_www_authenticate_class, fmt, ap);
  va_end(ap);
 
  return (sip_www_authenticate_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_authentication_info
 * @{
 */

/** Parse a Authentication-Info header. @internal */
SOFIAPUBFUN int sip_authentication_info_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Authentication-Info header. @internal */
SOFIAPUBFUN int sip_authentication_info_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_authentication_info_t from sip_t.
 * 
 */
#define sip_authentication_info(sip) \
  ((sip_authentication_info_t *)msg_header_access((msg_pub_t*)(sip), sip_authentication_info_class))

/**Initializer for structure sip_authentication_info_t.
 * 
 * A static sip_authentication_info_t structure must be initialized.
 * The SIP_AUTHENTICATION_INFO_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_authentication_info_t sip_authentication_info = SIP_AUTHENTICATION_INFO_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_AUTHENTICATION_INFO_INIT() SIP_HDR_INIT(authentication_info)

/**Initialize a structure sip_authentication_info_t.
 * 
 * An sip_authentication_info_t structure can be initialized with the
 * sip_authentication_info_init() function/macro. For instance,
 * @code
 * 
 *  sip_authentication_info_t sip_authentication_info;
 * 
 *  sip_authentication_info_init(&sip_authentication_info);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_authentication_info_t *sip_authentication_info_init(sip_authentication_info_t x[1])
{
  return SIP_HEADER_INIT(x, sip_authentication_info_class, sizeof(sip_authentication_info_t));
}
#else
#define sip_authentication_info_init(x) \
  SIP_HEADER_INIT(x, sip_authentication_info_class, sizeof(sip_authentication_info_t))
#endif

/**Test if header object is instance of sip_authentication_info_t.
 * 
 * The function sip_is_authentication_info() returns true (nonzero) if
 * the header class is an instance of Authentication-Info header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_authentication_info() returns true (nonzero) if
 * the header object is an instance of header authentication_info and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_authentication_info(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_authentication_info_hash;
}
#else
int sip_is_authentication_info(sip_header_t const *header);
#endif

#define sip_authentication_info_p(h) sip_is_authentication_info((h))


/**Duplicate (deep copy) @c sip_authentication_info_t.
 * 
 * The function sip_authentication_info_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   authentication_info = sip_authentication_info_dup(home, sip->sip_authentication_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_authentication_info_dup() returns a pointer to the
 * newly duplicated sip_authentication_info_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_authentication_info_t *sip_authentication_info_dup(su_home_t *home, sip_authentication_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_authentication_info_t *sip_authentication_info_dup(su_home_t *home, sip_authentication_info_t const *hdr)
{ 
  return (sip_authentication_info_t *)
    msg_header_dup_as(home, sip_authentication_info_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_authentication_info_t header structure.
 * 
 * The function sip_authentication_info_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   authentication_info = sip_authentication_info_copy(home, sip->sip_authentication_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_authentication_info_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_authentication_info_t *sip_authentication_info_copy(su_home_t *home, sip_authentication_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_authentication_info_t *sip_authentication_info_copy(su_home_t *home, sip_authentication_info_t const *hdr) 
{ 
  return (sip_authentication_info_t *)
    msg_header_copy_as(home, sip_authentication_info_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_authentication_info_t.
 * 
 * The function sip_authentication_info_make() makes a new
 * sip_authentication_info_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_authentication_info_make() returns a pointer to
 * newly maked sip_authentication_info_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_authentication_info_t *sip_authentication_info_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_authentication_info_t *sip_authentication_info_make(su_home_t *home, char const *s)
{
  return (sip_authentication_info_t *)sip_header_make(home, sip_authentication_info_class, s);
}
#endif

/**Make a Authentication-Info header from formatting result.
 * 
 * The function sip_authentication_info_format() makes a new
 * Authentication-Info header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_authentication_info_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_authentication_info_t *sip_authentication_info_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_authentication_info_t *sip_authentication_info_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_authentication_info_class, fmt, ap);
  va_end(ap);
 
  return (sip_authentication_info_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_error_info
 * @{
 */

/** Parse a Error-Info header. @internal */
SOFIAPUBFUN int sip_error_info_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Error-Info header. @internal */
SOFIAPUBFUN int sip_error_info_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_error_info_t from sip_t.
 * 
 */
#define sip_error_info(sip) \
  ((sip_error_info_t *)msg_header_access((msg_pub_t*)(sip), sip_error_info_class))

/**Initializer for structure sip_error_info_t.
 * 
 * A static sip_error_info_t structure must be initialized.
 * The SIP_ERROR_INFO_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_error_info_t sip_error_info = SIP_ERROR_INFO_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ERROR_INFO_INIT() SIP_HDR_INIT(error_info)

/**Initialize a structure sip_error_info_t.
 * 
 * An sip_error_info_t structure can be initialized with the
 * sip_error_info_init() function/macro. For instance,
 * @code
 * 
 *  sip_error_info_t sip_error_info;
 * 
 *  sip_error_info_init(&sip_error_info);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_error_info_t *sip_error_info_init(sip_error_info_t x[1])
{
  return SIP_HEADER_INIT(x, sip_error_info_class, sizeof(sip_error_info_t));
}
#else
#define sip_error_info_init(x) \
  SIP_HEADER_INIT(x, sip_error_info_class, sizeof(sip_error_info_t))
#endif

/**Test if header object is instance of sip_error_info_t.
 * 
 * The function sip_is_error_info() returns true (nonzero) if
 * the header class is an instance of Error-Info header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_error_info() returns true (nonzero) if
 * the header object is an instance of header error_info and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_error_info(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_error_info_hash;
}
#else
int sip_is_error_info(sip_header_t const *header);
#endif

#define sip_error_info_p(h) sip_is_error_info((h))


/**Duplicate (deep copy) @c sip_error_info_t.
 * 
 * The function sip_error_info_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   error_info = sip_error_info_dup(home, sip->sip_error_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_error_info_dup() returns a pointer to the
 * newly duplicated sip_error_info_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_error_info_t *sip_error_info_dup(su_home_t *home, sip_error_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_error_info_t *sip_error_info_dup(su_home_t *home, sip_error_info_t const *hdr)
{ 
  return (sip_error_info_t *)
    msg_header_dup_as(home, sip_error_info_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_error_info_t header structure.
 * 
 * The function sip_error_info_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   error_info = sip_error_info_copy(home, sip->sip_error_info);
 * 
 * @endcode
 * 
 * @return
 * The function sip_error_info_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_error_info_t *sip_error_info_copy(su_home_t *home, sip_error_info_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_error_info_t *sip_error_info_copy(su_home_t *home, sip_error_info_t const *hdr) 
{ 
  return (sip_error_info_t *)
    msg_header_copy_as(home, sip_error_info_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_error_info_t.
 * 
 * The function sip_error_info_make() makes a new
 * sip_error_info_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_error_info_make() returns a pointer to
 * newly maked sip_error_info_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_error_info_t *sip_error_info_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_error_info_t *sip_error_info_make(su_home_t *home, char const *s)
{
  return (sip_error_info_t *)sip_header_make(home, sip_error_info_class, s);
}
#endif

/**Make a Error-Info header from formatting result.
 * 
 * The function sip_error_info_format() makes a new
 * Error-Info header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_error_info_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_error_info_t *sip_error_info_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_error_info_t *sip_error_info_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_error_info_class, fmt, ap);
  va_end(ap);
 
  return (sip_error_info_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_warning
 * @{
 */

/** Parse a Warning header. @internal */
SOFIAPUBFUN int sip_warning_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Warning header. @internal */
SOFIAPUBFUN int sip_warning_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_warning_t from sip_t.
 * 
 */
#define sip_warning(sip) \
  ((sip_warning_t *)msg_header_access((msg_pub_t*)(sip), sip_warning_class))

/**Initializer for structure sip_warning_t.
 * 
 * A static sip_warning_t structure must be initialized.
 * The SIP_WARNING_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_warning_t sip_warning = SIP_WARNING_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_WARNING_INIT() SIP_HDR_INIT(warning)

/**Initialize a structure sip_warning_t.
 * 
 * An sip_warning_t structure can be initialized with the
 * sip_warning_init() function/macro. For instance,
 * @code
 * 
 *  sip_warning_t sip_warning;
 * 
 *  sip_warning_init(&sip_warning);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_warning_t *sip_warning_init(sip_warning_t x[1])
{
  return SIP_HEADER_INIT(x, sip_warning_class, sizeof(sip_warning_t));
}
#else
#define sip_warning_init(x) \
  SIP_HEADER_INIT(x, sip_warning_class, sizeof(sip_warning_t))
#endif

/**Test if header object is instance of sip_warning_t.
 * 
 * The function sip_is_warning() returns true (nonzero) if
 * the header class is an instance of Warning header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_warning() returns true (nonzero) if
 * the header object is an instance of header warning and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_warning(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_warning_hash;
}
#else
int sip_is_warning(sip_header_t const *header);
#endif

#define sip_warning_p(h) sip_is_warning((h))


/**Duplicate (deep copy) @c sip_warning_t.
 * 
 * The function sip_warning_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   warning = sip_warning_dup(home, sip->sip_warning);
 * 
 * @endcode
 * 
 * @return
 * The function sip_warning_dup() returns a pointer to the
 * newly duplicated sip_warning_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_warning_t *sip_warning_dup(su_home_t *home, sip_warning_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_warning_t *sip_warning_dup(su_home_t *home, sip_warning_t const *hdr)
{ 
  return (sip_warning_t *)
    msg_header_dup_as(home, sip_warning_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_warning_t header structure.
 * 
 * The function sip_warning_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   warning = sip_warning_copy(home, sip->sip_warning);
 * 
 * @endcode
 * 
 * @return
 * The function sip_warning_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_warning_t *sip_warning_copy(su_home_t *home, sip_warning_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_warning_t *sip_warning_copy(su_home_t *home, sip_warning_t const *hdr) 
{ 
  return (sip_warning_t *)
    msg_header_copy_as(home, sip_warning_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_warning_t.
 * 
 * The function sip_warning_make() makes a new
 * sip_warning_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_warning_make() returns a pointer to
 * newly maked sip_warning_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_warning_t *sip_warning_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_warning_t *sip_warning_make(su_home_t *home, char const *s)
{
  return (sip_warning_t *)sip_header_make(home, sip_warning_class, s);
}
#endif

/**Make a Warning header from formatting result.
 * 
 * The function sip_warning_format() makes a new
 * Warning header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_warning_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_warning_t *sip_warning_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_warning_t *sip_warning_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_warning_class, fmt, ap);
  va_end(ap);
 
  return (sip_warning_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_refer_to
 * @{
 */

/** Parse a Refer-To header. @internal */
SOFIAPUBFUN int sip_refer_to_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Refer-To header. @internal */
SOFIAPUBFUN int sip_refer_to_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_refer_to_t from sip_t.
 * 
 */
#define sip_refer_to(sip) \
  ((sip_refer_to_t *)msg_header_access((msg_pub_t*)(sip), sip_refer_to_class))

/**Initializer for structure sip_refer_to_t.
 * 
 * A static sip_refer_to_t structure must be initialized.
 * The SIP_REFER_TO_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_refer_to_t sip_refer_to = SIP_REFER_TO_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REFER_TO_INIT() SIP_HDR_INIT(refer_to)

/**Initialize a structure sip_refer_to_t.
 * 
 * An sip_refer_to_t structure can be initialized with the
 * sip_refer_to_init() function/macro. For instance,
 * @code
 * 
 *  sip_refer_to_t sip_refer_to;
 * 
 *  sip_refer_to_init(&sip_refer_to);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_refer_to_t *sip_refer_to_init(sip_refer_to_t x[1])
{
  return SIP_HEADER_INIT(x, sip_refer_to_class, sizeof(sip_refer_to_t));
}
#else
#define sip_refer_to_init(x) \
  SIP_HEADER_INIT(x, sip_refer_to_class, sizeof(sip_refer_to_t))
#endif

/**Test if header object is instance of sip_refer_to_t.
 * 
 * The function sip_is_refer_to() returns true (nonzero) if
 * the header class is an instance of Refer-To header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_refer_to() returns true (nonzero) if
 * the header object is an instance of header refer_to and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_refer_to(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_refer_to_hash;
}
#else
int sip_is_refer_to(sip_header_t const *header);
#endif

#define sip_refer_to_p(h) sip_is_refer_to((h))


/**Duplicate (deep copy) @c sip_refer_to_t.
 * 
 * The function sip_refer_to_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   refer_to = sip_refer_to_dup(home, sip->sip_refer_to);
 * 
 * @endcode
 * 
 * @return
 * The function sip_refer_to_dup() returns a pointer to the
 * newly duplicated sip_refer_to_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_refer_to_t *sip_refer_to_dup(su_home_t *home, sip_refer_to_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_refer_to_t *sip_refer_to_dup(su_home_t *home, sip_refer_to_t const *hdr)
{ 
  return (sip_refer_to_t *)
    msg_header_dup_as(home, sip_refer_to_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_refer_to_t header structure.
 * 
 * The function sip_refer_to_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   refer_to = sip_refer_to_copy(home, sip->sip_refer_to);
 * 
 * @endcode
 * 
 * @return
 * The function sip_refer_to_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_refer_to_t *sip_refer_to_copy(su_home_t *home, sip_refer_to_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_refer_to_t *sip_refer_to_copy(su_home_t *home, sip_refer_to_t const *hdr) 
{ 
  return (sip_refer_to_t *)
    msg_header_copy_as(home, sip_refer_to_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_refer_to_t.
 * 
 * The function sip_refer_to_make() makes a new
 * sip_refer_to_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_refer_to_make() returns a pointer to
 * newly maked sip_refer_to_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_refer_to_t *sip_refer_to_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_refer_to_t *sip_refer_to_make(su_home_t *home, char const *s)
{
  return (sip_refer_to_t *)sip_header_make(home, sip_refer_to_class, s);
}
#endif

/**Make a Refer-To header from formatting result.
 * 
 * The function sip_refer_to_format() makes a new
 * Refer-To header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_refer_to_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_refer_to_t *sip_refer_to_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_refer_to_t *sip_refer_to_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_refer_to_class, fmt, ap);
  va_end(ap);
 
  return (sip_refer_to_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_referred_by
 * @{
 */

/** Parse a Referred-By header. @internal */
SOFIAPUBFUN int sip_referred_by_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Referred-By header. @internal */
SOFIAPUBFUN int sip_referred_by_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_referred_by_t from sip_t.
 * 
 */
#define sip_referred_by(sip) \
  ((sip_referred_by_t *)msg_header_access((msg_pub_t*)(sip), sip_referred_by_class))

/**Initializer for structure sip_referred_by_t.
 * 
 * A static sip_referred_by_t structure must be initialized.
 * The SIP_REFERRED_BY_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_referred_by_t sip_referred_by = SIP_REFERRED_BY_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REFERRED_BY_INIT() SIP_HDR_INIT(referred_by)

/**Initialize a structure sip_referred_by_t.
 * 
 * An sip_referred_by_t structure can be initialized with the
 * sip_referred_by_init() function/macro. For instance,
 * @code
 * 
 *  sip_referred_by_t sip_referred_by;
 * 
 *  sip_referred_by_init(&sip_referred_by);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_referred_by_t *sip_referred_by_init(sip_referred_by_t x[1])
{
  return SIP_HEADER_INIT(x, sip_referred_by_class, sizeof(sip_referred_by_t));
}
#else
#define sip_referred_by_init(x) \
  SIP_HEADER_INIT(x, sip_referred_by_class, sizeof(sip_referred_by_t))
#endif

/**Test if header object is instance of sip_referred_by_t.
 * 
 * The function sip_is_referred_by() returns true (nonzero) if
 * the header class is an instance of Referred-By header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_referred_by() returns true (nonzero) if
 * the header object is an instance of header referred_by and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_referred_by(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_referred_by_hash;
}
#else
int sip_is_referred_by(sip_header_t const *header);
#endif

#define sip_referred_by_p(h) sip_is_referred_by((h))


/**Duplicate (deep copy) @c sip_referred_by_t.
 * 
 * The function sip_referred_by_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   referred_by = sip_referred_by_dup(home, sip->sip_referred_by);
 * 
 * @endcode
 * 
 * @return
 * The function sip_referred_by_dup() returns a pointer to the
 * newly duplicated sip_referred_by_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_referred_by_t *sip_referred_by_dup(su_home_t *home, sip_referred_by_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_referred_by_t *sip_referred_by_dup(su_home_t *home, sip_referred_by_t const *hdr)
{ 
  return (sip_referred_by_t *)
    msg_header_dup_as(home, sip_referred_by_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_referred_by_t header structure.
 * 
 * The function sip_referred_by_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   referred_by = sip_referred_by_copy(home, sip->sip_referred_by);
 * 
 * @endcode
 * 
 * @return
 * The function sip_referred_by_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_referred_by_t *sip_referred_by_copy(su_home_t *home, sip_referred_by_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_referred_by_t *sip_referred_by_copy(su_home_t *home, sip_referred_by_t const *hdr) 
{ 
  return (sip_referred_by_t *)
    msg_header_copy_as(home, sip_referred_by_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_referred_by_t.
 * 
 * The function sip_referred_by_make() makes a new
 * sip_referred_by_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_referred_by_make() returns a pointer to
 * newly maked sip_referred_by_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_referred_by_t *sip_referred_by_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_referred_by_t *sip_referred_by_make(su_home_t *home, char const *s)
{
  return (sip_referred_by_t *)sip_header_make(home, sip_referred_by_class, s);
}
#endif

/**Make a Referred-By header from formatting result.
 * 
 * The function sip_referred_by_format() makes a new
 * Referred-By header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_referred_by_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_referred_by_t *sip_referred_by_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_referred_by_t *sip_referred_by_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_referred_by_class, fmt, ap);
  va_end(ap);
 
  return (sip_referred_by_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_replaces
 * @{
 */

/** Parse a Replaces header. @internal */
SOFIAPUBFUN int sip_replaces_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Replaces header. @internal */
SOFIAPUBFUN int sip_replaces_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_replaces_t from sip_t.
 * 
 */
#define sip_replaces(sip) \
  ((sip_replaces_t *)msg_header_access((msg_pub_t*)(sip), sip_replaces_class))

/**Initializer for structure sip_replaces_t.
 * 
 * A static sip_replaces_t structure must be initialized.
 * The SIP_REPLACES_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_replaces_t sip_replaces = SIP_REPLACES_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REPLACES_INIT() SIP_HDR_INIT(replaces)

/**Initialize a structure sip_replaces_t.
 * 
 * An sip_replaces_t structure can be initialized with the
 * sip_replaces_init() function/macro. For instance,
 * @code
 * 
 *  sip_replaces_t sip_replaces;
 * 
 *  sip_replaces_init(&sip_replaces);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_replaces_t *sip_replaces_init(sip_replaces_t x[1])
{
  return SIP_HEADER_INIT(x, sip_replaces_class, sizeof(sip_replaces_t));
}
#else
#define sip_replaces_init(x) \
  SIP_HEADER_INIT(x, sip_replaces_class, sizeof(sip_replaces_t))
#endif

/**Test if header object is instance of sip_replaces_t.
 * 
 * The function sip_is_replaces() returns true (nonzero) if
 * the header class is an instance of Replaces header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_replaces() returns true (nonzero) if
 * the header object is an instance of header replaces and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_replaces(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_replaces_hash;
}
#else
int sip_is_replaces(sip_header_t const *header);
#endif

#define sip_replaces_p(h) sip_is_replaces((h))


/**Duplicate (deep copy) @c sip_replaces_t.
 * 
 * The function sip_replaces_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   replaces = sip_replaces_dup(home, sip->sip_replaces);
 * 
 * @endcode
 * 
 * @return
 * The function sip_replaces_dup() returns a pointer to the
 * newly duplicated sip_replaces_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_replaces_t *sip_replaces_dup(su_home_t *home, sip_replaces_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_replaces_t *sip_replaces_dup(su_home_t *home, sip_replaces_t const *hdr)
{ 
  return (sip_replaces_t *)
    msg_header_dup_as(home, sip_replaces_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_replaces_t header structure.
 * 
 * The function sip_replaces_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   replaces = sip_replaces_copy(home, sip->sip_replaces);
 * 
 * @endcode
 * 
 * @return
 * The function sip_replaces_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_replaces_t *sip_replaces_copy(su_home_t *home, sip_replaces_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_replaces_t *sip_replaces_copy(su_home_t *home, sip_replaces_t const *hdr) 
{ 
  return (sip_replaces_t *)
    msg_header_copy_as(home, sip_replaces_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_replaces_t.
 * 
 * The function sip_replaces_make() makes a new
 * sip_replaces_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_replaces_make() returns a pointer to
 * newly maked sip_replaces_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_replaces_t *sip_replaces_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_replaces_t *sip_replaces_make(su_home_t *home, char const *s)
{
  return (sip_replaces_t *)sip_header_make(home, sip_replaces_class, s);
}
#endif

/**Make a Replaces header from formatting result.
 * 
 * The function sip_replaces_format() makes a new
 * Replaces header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_replaces_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_replaces_t *sip_replaces_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_replaces_t *sip_replaces_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_replaces_class, fmt, ap);
  va_end(ap);
 
  return (sip_replaces_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_session_expires
 * @{
 */

/** Parse a Session-Expires header. @internal */
SOFIAPUBFUN int sip_session_expires_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Session-Expires header. @internal */
SOFIAPUBFUN int sip_session_expires_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_session_expires_t from sip_t.
 * 
 */
#define sip_session_expires(sip) \
  ((sip_session_expires_t *)msg_header_access((msg_pub_t*)(sip), sip_session_expires_class))

/**Initializer for structure sip_session_expires_t.
 * 
 * A static sip_session_expires_t structure must be initialized.
 * The SIP_SESSION_EXPIRES_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_session_expires_t sip_session_expires = SIP_SESSION_EXPIRES_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SESSION_EXPIRES_INIT() SIP_HDR_INIT(session_expires)

/**Initialize a structure sip_session_expires_t.
 * 
 * An sip_session_expires_t structure can be initialized with the
 * sip_session_expires_init() function/macro. For instance,
 * @code
 * 
 *  sip_session_expires_t sip_session_expires;
 * 
 *  sip_session_expires_init(&sip_session_expires);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_session_expires_t *sip_session_expires_init(sip_session_expires_t x[1])
{
  return SIP_HEADER_INIT(x, sip_session_expires_class, sizeof(sip_session_expires_t));
}
#else
#define sip_session_expires_init(x) \
  SIP_HEADER_INIT(x, sip_session_expires_class, sizeof(sip_session_expires_t))
#endif

/**Test if header object is instance of sip_session_expires_t.
 * 
 * The function sip_is_session_expires() returns true (nonzero) if
 * the header class is an instance of Session-Expires header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_session_expires() returns true (nonzero) if
 * the header object is an instance of header session_expires and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_session_expires(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_session_expires_hash;
}
#else
int sip_is_session_expires(sip_header_t const *header);
#endif

#define sip_session_expires_p(h) sip_is_session_expires((h))


/**Duplicate (deep copy) @c sip_session_expires_t.
 * 
 * The function sip_session_expires_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   session_expires = sip_session_expires_dup(home, sip->sip_session_expires);
 * 
 * @endcode
 * 
 * @return
 * The function sip_session_expires_dup() returns a pointer to the
 * newly duplicated sip_session_expires_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_session_expires_t *sip_session_expires_dup(su_home_t *home, sip_session_expires_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_session_expires_t *sip_session_expires_dup(su_home_t *home, sip_session_expires_t const *hdr)
{ 
  return (sip_session_expires_t *)
    msg_header_dup_as(home, sip_session_expires_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_session_expires_t header structure.
 * 
 * The function sip_session_expires_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   session_expires = sip_session_expires_copy(home, sip->sip_session_expires);
 * 
 * @endcode
 * 
 * @return
 * The function sip_session_expires_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_session_expires_t *sip_session_expires_copy(su_home_t *home, sip_session_expires_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_session_expires_t *sip_session_expires_copy(su_home_t *home, sip_session_expires_t const *hdr) 
{ 
  return (sip_session_expires_t *)
    msg_header_copy_as(home, sip_session_expires_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_session_expires_t.
 * 
 * The function sip_session_expires_make() makes a new
 * sip_session_expires_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_session_expires_make() returns a pointer to
 * newly maked sip_session_expires_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_session_expires_t *sip_session_expires_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_session_expires_t *sip_session_expires_make(su_home_t *home, char const *s)
{
  return (sip_session_expires_t *)sip_header_make(home, sip_session_expires_class, s);
}
#endif

/**Make a Session-Expires header from formatting result.
 * 
 * The function sip_session_expires_format() makes a new
 * Session-Expires header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_session_expires_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_session_expires_t *sip_session_expires_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_session_expires_t *sip_session_expires_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_session_expires_class, fmt, ap);
  va_end(ap);
 
  return (sip_session_expires_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_min_se
 * @{
 */

/** Parse a Min-SE header. @internal */
SOFIAPUBFUN int sip_min_se_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Min-SE header. @internal */
SOFIAPUBFUN int sip_min_se_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_min_se_t from sip_t.
 * 
 */
#define sip_min_se(sip) \
  ((sip_min_se_t *)msg_header_access((msg_pub_t*)(sip), sip_min_se_class))

/**Initializer for structure sip_min_se_t.
 * 
 * A static sip_min_se_t structure must be initialized.
 * The SIP_MIN_SE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_min_se_t sip_min_se = SIP_MIN_SE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_MIN_SE_INIT() SIP_HDR_INIT(min_se)

/**Initialize a structure sip_min_se_t.
 * 
 * An sip_min_se_t structure can be initialized with the
 * sip_min_se_init() function/macro. For instance,
 * @code
 * 
 *  sip_min_se_t sip_min_se;
 * 
 *  sip_min_se_init(&sip_min_se);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_min_se_t *sip_min_se_init(sip_min_se_t x[1])
{
  return SIP_HEADER_INIT(x, sip_min_se_class, sizeof(sip_min_se_t));
}
#else
#define sip_min_se_init(x) \
  SIP_HEADER_INIT(x, sip_min_se_class, sizeof(sip_min_se_t))
#endif

/**Test if header object is instance of sip_min_se_t.
 * 
 * The function sip_is_min_se() returns true (nonzero) if
 * the header class is an instance of Min-SE header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_min_se() returns true (nonzero) if
 * the header object is an instance of header min_se and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_min_se(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_min_se_hash;
}
#else
int sip_is_min_se(sip_header_t const *header);
#endif

#define sip_min_se_p(h) sip_is_min_se((h))


/**Duplicate (deep copy) @c sip_min_se_t.
 * 
 * The function sip_min_se_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   min_se = sip_min_se_dup(home, sip->sip_min_se);
 * 
 * @endcode
 * 
 * @return
 * The function sip_min_se_dup() returns a pointer to the
 * newly duplicated sip_min_se_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_min_se_t *sip_min_se_dup(su_home_t *home, sip_min_se_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_min_se_t *sip_min_se_dup(su_home_t *home, sip_min_se_t const *hdr)
{ 
  return (sip_min_se_t *)
    msg_header_dup_as(home, sip_min_se_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_min_se_t header structure.
 * 
 * The function sip_min_se_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   min_se = sip_min_se_copy(home, sip->sip_min_se);
 * 
 * @endcode
 * 
 * @return
 * The function sip_min_se_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_min_se_t *sip_min_se_copy(su_home_t *home, sip_min_se_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_min_se_t *sip_min_se_copy(su_home_t *home, sip_min_se_t const *hdr) 
{ 
  return (sip_min_se_t *)
    msg_header_copy_as(home, sip_min_se_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_min_se_t.
 * 
 * The function sip_min_se_make() makes a new
 * sip_min_se_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_min_se_make() returns a pointer to
 * newly maked sip_min_se_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_min_se_t *sip_min_se_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_min_se_t *sip_min_se_make(su_home_t *home, char const *s)
{
  return (sip_min_se_t *)sip_header_make(home, sip_min_se_class, s);
}
#endif

/**Make a Min-SE header from formatting result.
 * 
 * The function sip_min_se_format() makes a new
 * Min-SE header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_min_se_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_min_se_t *sip_min_se_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_min_se_t *sip_min_se_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_min_se_class, fmt, ap);
  va_end(ap);
 
  return (sip_min_se_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_path
 * @{
 */

/** Parse a Path header. @internal */
SOFIAPUBFUN int sip_path_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Path header. @internal */
SOFIAPUBFUN int sip_path_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_path_t from sip_t.
 * 
 */
#define sip_path(sip) \
  ((sip_path_t *)msg_header_access((msg_pub_t*)(sip), sip_path_class))

/**Initializer for structure sip_path_t.
 * 
 * A static sip_path_t structure must be initialized.
 * The SIP_PATH_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_path_t sip_path = SIP_PATH_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PATH_INIT() SIP_HDR_INIT(path)

/**Initialize a structure sip_path_t.
 * 
 * An sip_path_t structure can be initialized with the
 * sip_path_init() function/macro. For instance,
 * @code
 * 
 *  sip_path_t sip_path;
 * 
 *  sip_path_init(&sip_path);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_path_t *sip_path_init(sip_path_t x[1])
{
  return SIP_HEADER_INIT(x, sip_path_class, sizeof(sip_path_t));
}
#else
#define sip_path_init(x) \
  SIP_HEADER_INIT(x, sip_path_class, sizeof(sip_path_t))
#endif

/**Test if header object is instance of sip_path_t.
 * 
 * The function sip_is_path() returns true (nonzero) if
 * the header class is an instance of Path header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_path() returns true (nonzero) if
 * the header object is an instance of header path and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_path(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_path_hash;
}
#else
int sip_is_path(sip_header_t const *header);
#endif

#define sip_path_p(h) sip_is_path((h))


/**Duplicate (deep copy) @c sip_path_t.
 * 
 * The function sip_path_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   path = sip_path_dup(home, sip->sip_path);
 * 
 * @endcode
 * 
 * @return
 * The function sip_path_dup() returns a pointer to the
 * newly duplicated sip_path_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_path_t *sip_path_dup(su_home_t *home, sip_path_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_path_t *sip_path_dup(su_home_t *home, sip_path_t const *hdr)
{ 
  return (sip_path_t *)
    msg_header_dup_as(home, sip_path_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_path_t header structure.
 * 
 * The function sip_path_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   path = sip_path_copy(home, sip->sip_path);
 * 
 * @endcode
 * 
 * @return
 * The function sip_path_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_path_t *sip_path_copy(su_home_t *home, sip_path_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_path_t *sip_path_copy(su_home_t *home, sip_path_t const *hdr) 
{ 
  return (sip_path_t *)
    msg_header_copy_as(home, sip_path_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_path_t.
 * 
 * The function sip_path_make() makes a new
 * sip_path_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_path_make() returns a pointer to
 * newly maked sip_path_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_path_t *sip_path_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_path_t *sip_path_make(su_home_t *home, char const *s)
{
  return (sip_path_t *)sip_header_make(home, sip_path_class, s);
}
#endif

/**Make a Path header from formatting result.
 * 
 * The function sip_path_format() makes a new
 * Path header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_path_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_path_t *sip_path_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_path_t *sip_path_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_path_class, fmt, ap);
  va_end(ap);
 
  return (sip_path_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_service_route
 * @{
 */

/** Parse a Service-Route header. @internal */
SOFIAPUBFUN int sip_service_route_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Service-Route header. @internal */
SOFIAPUBFUN int sip_service_route_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_service_route_t from sip_t.
 * 
 */
#define sip_service_route(sip) \
  ((sip_service_route_t *)msg_header_access((msg_pub_t*)(sip), sip_service_route_class))

/**Initializer for structure sip_service_route_t.
 * 
 * A static sip_service_route_t structure must be initialized.
 * The SIP_SERVICE_ROUTE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_service_route_t sip_service_route = SIP_SERVICE_ROUTE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SERVICE_ROUTE_INIT() SIP_HDR_INIT(service_route)

/**Initialize a structure sip_service_route_t.
 * 
 * An sip_service_route_t structure can be initialized with the
 * sip_service_route_init() function/macro. For instance,
 * @code
 * 
 *  sip_service_route_t sip_service_route;
 * 
 *  sip_service_route_init(&sip_service_route);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_service_route_t *sip_service_route_init(sip_service_route_t x[1])
{
  return SIP_HEADER_INIT(x, sip_service_route_class, sizeof(sip_service_route_t));
}
#else
#define sip_service_route_init(x) \
  SIP_HEADER_INIT(x, sip_service_route_class, sizeof(sip_service_route_t))
#endif

/**Test if header object is instance of sip_service_route_t.
 * 
 * The function sip_is_service_route() returns true (nonzero) if
 * the header class is an instance of Service-Route header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_service_route() returns true (nonzero) if
 * the header object is an instance of header service_route and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_service_route(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_service_route_hash;
}
#else
int sip_is_service_route(sip_header_t const *header);
#endif

#define sip_service_route_p(h) sip_is_service_route((h))


/**Duplicate (deep copy) @c sip_service_route_t.
 * 
 * The function sip_service_route_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   service_route = sip_service_route_dup(home, sip->sip_service_route);
 * 
 * @endcode
 * 
 * @return
 * The function sip_service_route_dup() returns a pointer to the
 * newly duplicated sip_service_route_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_service_route_t *sip_service_route_dup(su_home_t *home, sip_service_route_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_service_route_t *sip_service_route_dup(su_home_t *home, sip_service_route_t const *hdr)
{ 
  return (sip_service_route_t *)
    msg_header_dup_as(home, sip_service_route_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_service_route_t header structure.
 * 
 * The function sip_service_route_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   service_route = sip_service_route_copy(home, sip->sip_service_route);
 * 
 * @endcode
 * 
 * @return
 * The function sip_service_route_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_service_route_t *sip_service_route_copy(su_home_t *home, sip_service_route_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_service_route_t *sip_service_route_copy(su_home_t *home, sip_service_route_t const *hdr) 
{ 
  return (sip_service_route_t *)
    msg_header_copy_as(home, sip_service_route_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_service_route_t.
 * 
 * The function sip_service_route_make() makes a new
 * sip_service_route_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_service_route_make() returns a pointer to
 * newly maked sip_service_route_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_service_route_t *sip_service_route_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_service_route_t *sip_service_route_make(su_home_t *home, char const *s)
{
  return (sip_service_route_t *)sip_header_make(home, sip_service_route_class, s);
}
#endif

/**Make a Service-Route header from formatting result.
 * 
 * The function sip_service_route_format() makes a new
 * Service-Route header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_service_route_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_service_route_t *sip_service_route_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_service_route_t *sip_service_route_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_service_route_class, fmt, ap);
  va_end(ap);
 
  return (sip_service_route_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_reason
 * @{
 */

/** Parse a Reason header. @internal */
SOFIAPUBFUN int sip_reason_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Reason header. @internal */
SOFIAPUBFUN int sip_reason_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_reason_t from sip_t.
 * 
 */
#define sip_reason(sip) \
  ((sip_reason_t *)msg_header_access((msg_pub_t*)(sip), sip_reason_class))

/**Initializer for structure sip_reason_t.
 * 
 * A static sip_reason_t structure must be initialized.
 * The SIP_REASON_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_reason_t sip_reason = SIP_REASON_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_REASON_INIT() SIP_HDR_INIT(reason)

/**Initialize a structure sip_reason_t.
 * 
 * An sip_reason_t structure can be initialized with the
 * sip_reason_init() function/macro. For instance,
 * @code
 * 
 *  sip_reason_t sip_reason;
 * 
 *  sip_reason_init(&sip_reason);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_reason_t *sip_reason_init(sip_reason_t x[1])
{
  return SIP_HEADER_INIT(x, sip_reason_class, sizeof(sip_reason_t));
}
#else
#define sip_reason_init(x) \
  SIP_HEADER_INIT(x, sip_reason_class, sizeof(sip_reason_t))
#endif

/**Test if header object is instance of sip_reason_t.
 * 
 * The function sip_is_reason() returns true (nonzero) if
 * the header class is an instance of Reason header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_reason() returns true (nonzero) if
 * the header object is an instance of header reason and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_reason(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_reason_hash;
}
#else
int sip_is_reason(sip_header_t const *header);
#endif

#define sip_reason_p(h) sip_is_reason((h))


/**Duplicate (deep copy) @c sip_reason_t.
 * 
 * The function sip_reason_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   reason = sip_reason_dup(home, sip->sip_reason);
 * 
 * @endcode
 * 
 * @return
 * The function sip_reason_dup() returns a pointer to the
 * newly duplicated sip_reason_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_reason_t *sip_reason_dup(su_home_t *home, sip_reason_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_reason_t *sip_reason_dup(su_home_t *home, sip_reason_t const *hdr)
{ 
  return (sip_reason_t *)
    msg_header_dup_as(home, sip_reason_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_reason_t header structure.
 * 
 * The function sip_reason_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   reason = sip_reason_copy(home, sip->sip_reason);
 * 
 * @endcode
 * 
 * @return
 * The function sip_reason_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_reason_t *sip_reason_copy(su_home_t *home, sip_reason_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_reason_t *sip_reason_copy(su_home_t *home, sip_reason_t const *hdr) 
{ 
  return (sip_reason_t *)
    msg_header_copy_as(home, sip_reason_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_reason_t.
 * 
 * The function sip_reason_make() makes a new
 * sip_reason_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_reason_make() returns a pointer to
 * newly maked sip_reason_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_reason_t *sip_reason_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_reason_t *sip_reason_make(su_home_t *home, char const *s)
{
  return (sip_reason_t *)sip_header_make(home, sip_reason_class, s);
}
#endif

/**Make a Reason header from formatting result.
 * 
 * The function sip_reason_format() makes a new
 * Reason header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_reason_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_reason_t *sip_reason_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_reason_t *sip_reason_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_reason_class, fmt, ap);
  va_end(ap);
 
  return (sip_reason_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_security_client
 * @{
 */

/** Parse a Security-Client header. @internal */
SOFIAPUBFUN int sip_security_client_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Security-Client header. @internal */
SOFIAPUBFUN int sip_security_client_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_security_client_t from sip_t.
 * 
 */
#define sip_security_client(sip) \
  ((sip_security_client_t *)msg_header_access((msg_pub_t*)(sip), sip_security_client_class))

/**Initializer for structure sip_security_client_t.
 * 
 * A static sip_security_client_t structure must be initialized.
 * The SIP_SECURITY_CLIENT_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_security_client_t sip_security_client = SIP_SECURITY_CLIENT_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SECURITY_CLIENT_INIT() SIP_HDR_INIT(security_client)

/**Initialize a structure sip_security_client_t.
 * 
 * An sip_security_client_t structure can be initialized with the
 * sip_security_client_init() function/macro. For instance,
 * @code
 * 
 *  sip_security_client_t sip_security_client;
 * 
 *  sip_security_client_init(&sip_security_client);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_security_client_t *sip_security_client_init(sip_security_client_t x[1])
{
  return SIP_HEADER_INIT(x, sip_security_client_class, sizeof(sip_security_client_t));
}
#else
#define sip_security_client_init(x) \
  SIP_HEADER_INIT(x, sip_security_client_class, sizeof(sip_security_client_t))
#endif

/**Test if header object is instance of sip_security_client_t.
 * 
 * The function sip_is_security_client() returns true (nonzero) if
 * the header class is an instance of Security-Client header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_security_client() returns true (nonzero) if
 * the header object is an instance of header security_client and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_security_client(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_security_client_hash;
}
#else
int sip_is_security_client(sip_header_t const *header);
#endif

#define sip_security_client_p(h) sip_is_security_client((h))


/**Duplicate (deep copy) @c sip_security_client_t.
 * 
 * The function sip_security_client_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   security_client = sip_security_client_dup(home, sip->sip_security_client);
 * 
 * @endcode
 * 
 * @return
 * The function sip_security_client_dup() returns a pointer to the
 * newly duplicated sip_security_client_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_client_t *sip_security_client_dup(su_home_t *home, sip_security_client_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_security_client_t *sip_security_client_dup(su_home_t *home, sip_security_client_t const *hdr)
{ 
  return (sip_security_client_t *)
    msg_header_dup_as(home, sip_security_client_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_security_client_t header structure.
 * 
 * The function sip_security_client_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   security_client = sip_security_client_copy(home, sip->sip_security_client);
 * 
 * @endcode
 * 
 * @return
 * The function sip_security_client_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_client_t *sip_security_client_copy(su_home_t *home, sip_security_client_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_security_client_t *sip_security_client_copy(su_home_t *home, sip_security_client_t const *hdr) 
{ 
  return (sip_security_client_t *)
    msg_header_copy_as(home, sip_security_client_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_security_client_t.
 * 
 * The function sip_security_client_make() makes a new
 * sip_security_client_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_security_client_make() returns a pointer to
 * newly maked sip_security_client_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_security_client_t *sip_security_client_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_security_client_t *sip_security_client_make(su_home_t *home, char const *s)
{
  return (sip_security_client_t *)sip_header_make(home, sip_security_client_class, s);
}
#endif

/**Make a Security-Client header from formatting result.
 * 
 * The function sip_security_client_format() makes a new
 * Security-Client header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_security_client_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_client_t *sip_security_client_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_security_client_t *sip_security_client_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_security_client_class, fmt, ap);
  va_end(ap);
 
  return (sip_security_client_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_security_server
 * @{
 */

/** Parse a Security-Server header. @internal */
SOFIAPUBFUN int sip_security_server_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Security-Server header. @internal */
SOFIAPUBFUN int sip_security_server_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_security_server_t from sip_t.
 * 
 */
#define sip_security_server(sip) \
  ((sip_security_server_t *)msg_header_access((msg_pub_t*)(sip), sip_security_server_class))

/**Initializer for structure sip_security_server_t.
 * 
 * A static sip_security_server_t structure must be initialized.
 * The SIP_SECURITY_SERVER_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_security_server_t sip_security_server = SIP_SECURITY_SERVER_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SECURITY_SERVER_INIT() SIP_HDR_INIT(security_server)

/**Initialize a structure sip_security_server_t.
 * 
 * An sip_security_server_t structure can be initialized with the
 * sip_security_server_init() function/macro. For instance,
 * @code
 * 
 *  sip_security_server_t sip_security_server;
 * 
 *  sip_security_server_init(&sip_security_server);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_security_server_t *sip_security_server_init(sip_security_server_t x[1])
{
  return SIP_HEADER_INIT(x, sip_security_server_class, sizeof(sip_security_server_t));
}
#else
#define sip_security_server_init(x) \
  SIP_HEADER_INIT(x, sip_security_server_class, sizeof(sip_security_server_t))
#endif

/**Test if header object is instance of sip_security_server_t.
 * 
 * The function sip_is_security_server() returns true (nonzero) if
 * the header class is an instance of Security-Server header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_security_server() returns true (nonzero) if
 * the header object is an instance of header security_server and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_security_server(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_security_server_hash;
}
#else
int sip_is_security_server(sip_header_t const *header);
#endif

#define sip_security_server_p(h) sip_is_security_server((h))


/**Duplicate (deep copy) @c sip_security_server_t.
 * 
 * The function sip_security_server_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   security_server = sip_security_server_dup(home, sip->sip_security_server);
 * 
 * @endcode
 * 
 * @return
 * The function sip_security_server_dup() returns a pointer to the
 * newly duplicated sip_security_server_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_server_t *sip_security_server_dup(su_home_t *home, sip_security_server_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_security_server_t *sip_security_server_dup(su_home_t *home, sip_security_server_t const *hdr)
{ 
  return (sip_security_server_t *)
    msg_header_dup_as(home, sip_security_server_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_security_server_t header structure.
 * 
 * The function sip_security_server_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   security_server = sip_security_server_copy(home, sip->sip_security_server);
 * 
 * @endcode
 * 
 * @return
 * The function sip_security_server_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_server_t *sip_security_server_copy(su_home_t *home, sip_security_server_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_security_server_t *sip_security_server_copy(su_home_t *home, sip_security_server_t const *hdr) 
{ 
  return (sip_security_server_t *)
    msg_header_copy_as(home, sip_security_server_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_security_server_t.
 * 
 * The function sip_security_server_make() makes a new
 * sip_security_server_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_security_server_make() returns a pointer to
 * newly maked sip_security_server_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_security_server_t *sip_security_server_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_security_server_t *sip_security_server_make(su_home_t *home, char const *s)
{
  return (sip_security_server_t *)sip_header_make(home, sip_security_server_class, s);
}
#endif

/**Make a Security-Server header from formatting result.
 * 
 * The function sip_security_server_format() makes a new
 * Security-Server header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_security_server_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_server_t *sip_security_server_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_security_server_t *sip_security_server_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_security_server_class, fmt, ap);
  va_end(ap);
 
  return (sip_security_server_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_security_verify
 * @{
 */

/** Parse a Security-Verify header. @internal */
SOFIAPUBFUN int sip_security_verify_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Security-Verify header. @internal */
SOFIAPUBFUN int sip_security_verify_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_security_verify_t from sip_t.
 * 
 */
#define sip_security_verify(sip) \
  ((sip_security_verify_t *)msg_header_access((msg_pub_t*)(sip), sip_security_verify_class))

/**Initializer for structure sip_security_verify_t.
 * 
 * A static sip_security_verify_t structure must be initialized.
 * The SIP_SECURITY_VERIFY_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_security_verify_t sip_security_verify = SIP_SECURITY_VERIFY_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SECURITY_VERIFY_INIT() SIP_HDR_INIT(security_verify)

/**Initialize a structure sip_security_verify_t.
 * 
 * An sip_security_verify_t structure can be initialized with the
 * sip_security_verify_init() function/macro. For instance,
 * @code
 * 
 *  sip_security_verify_t sip_security_verify;
 * 
 *  sip_security_verify_init(&sip_security_verify);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_security_verify_t *sip_security_verify_init(sip_security_verify_t x[1])
{
  return SIP_HEADER_INIT(x, sip_security_verify_class, sizeof(sip_security_verify_t));
}
#else
#define sip_security_verify_init(x) \
  SIP_HEADER_INIT(x, sip_security_verify_class, sizeof(sip_security_verify_t))
#endif

/**Test if header object is instance of sip_security_verify_t.
 * 
 * The function sip_is_security_verify() returns true (nonzero) if
 * the header class is an instance of Security-Verify header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_security_verify() returns true (nonzero) if
 * the header object is an instance of header security_verify and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_security_verify(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_security_verify_hash;
}
#else
int sip_is_security_verify(sip_header_t const *header);
#endif

#define sip_security_verify_p(h) sip_is_security_verify((h))


/**Duplicate (deep copy) @c sip_security_verify_t.
 * 
 * The function sip_security_verify_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   security_verify = sip_security_verify_dup(home, sip->sip_security_verify);
 * 
 * @endcode
 * 
 * @return
 * The function sip_security_verify_dup() returns a pointer to the
 * newly duplicated sip_security_verify_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_verify_t *sip_security_verify_dup(su_home_t *home, sip_security_verify_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_security_verify_t *sip_security_verify_dup(su_home_t *home, sip_security_verify_t const *hdr)
{ 
  return (sip_security_verify_t *)
    msg_header_dup_as(home, sip_security_verify_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_security_verify_t header structure.
 * 
 * The function sip_security_verify_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   security_verify = sip_security_verify_copy(home, sip->sip_security_verify);
 * 
 * @endcode
 * 
 * @return
 * The function sip_security_verify_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_verify_t *sip_security_verify_copy(su_home_t *home, sip_security_verify_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_security_verify_t *sip_security_verify_copy(su_home_t *home, sip_security_verify_t const *hdr) 
{ 
  return (sip_security_verify_t *)
    msg_header_copy_as(home, sip_security_verify_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_security_verify_t.
 * 
 * The function sip_security_verify_make() makes a new
 * sip_security_verify_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_security_verify_make() returns a pointer to
 * newly maked sip_security_verify_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_security_verify_t *sip_security_verify_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_security_verify_t *sip_security_verify_make(su_home_t *home, char const *s)
{
  return (sip_security_verify_t *)sip_header_make(home, sip_security_verify_class, s);
}
#endif

/**Make a Security-Verify header from formatting result.
 * 
 * The function sip_security_verify_format() makes a new
 * Security-Verify header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_security_verify_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_security_verify_t *sip_security_verify_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_security_verify_t *sip_security_verify_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_security_verify_class, fmt, ap);
  va_end(ap);
 
  return (sip_security_verify_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_privacy
 * @{
 */

/** Parse a Privacy header. @internal */
SOFIAPUBFUN int sip_privacy_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Privacy header. @internal */
SOFIAPUBFUN int sip_privacy_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_privacy_t from sip_t.
 * 
 */
#define sip_privacy(sip) \
  ((sip_privacy_t *)msg_header_access((msg_pub_t*)(sip), sip_privacy_class))

/**Initializer for structure sip_privacy_t.
 * 
 * A static sip_privacy_t structure must be initialized.
 * The SIP_PRIVACY_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_privacy_t sip_privacy = SIP_PRIVACY_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PRIVACY_INIT() SIP_HDR_INIT(privacy)

/**Initialize a structure sip_privacy_t.
 * 
 * An sip_privacy_t structure can be initialized with the
 * sip_privacy_init() function/macro. For instance,
 * @code
 * 
 *  sip_privacy_t sip_privacy;
 * 
 *  sip_privacy_init(&sip_privacy);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_privacy_t *sip_privacy_init(sip_privacy_t x[1])
{
  return SIP_HEADER_INIT(x, sip_privacy_class, sizeof(sip_privacy_t));
}
#else
#define sip_privacy_init(x) \
  SIP_HEADER_INIT(x, sip_privacy_class, sizeof(sip_privacy_t))
#endif

/**Test if header object is instance of sip_privacy_t.
 * 
 * The function sip_is_privacy() returns true (nonzero) if
 * the header class is an instance of Privacy header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_privacy() returns true (nonzero) if
 * the header object is an instance of header privacy and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_privacy(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_privacy_hash;
}
#else
int sip_is_privacy(sip_header_t const *header);
#endif

#define sip_privacy_p(h) sip_is_privacy((h))


/**Duplicate (deep copy) @c sip_privacy_t.
 * 
 * The function sip_privacy_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   privacy = sip_privacy_dup(home, sip->sip_privacy);
 * 
 * @endcode
 * 
 * @return
 * The function sip_privacy_dup() returns a pointer to the
 * newly duplicated sip_privacy_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_privacy_t *sip_privacy_dup(su_home_t *home, sip_privacy_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_privacy_t *sip_privacy_dup(su_home_t *home, sip_privacy_t const *hdr)
{ 
  return (sip_privacy_t *)
    msg_header_dup_as(home, sip_privacy_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_privacy_t header structure.
 * 
 * The function sip_privacy_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   privacy = sip_privacy_copy(home, sip->sip_privacy);
 * 
 * @endcode
 * 
 * @return
 * The function sip_privacy_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_privacy_t *sip_privacy_copy(su_home_t *home, sip_privacy_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_privacy_t *sip_privacy_copy(su_home_t *home, sip_privacy_t const *hdr) 
{ 
  return (sip_privacy_t *)
    msg_header_copy_as(home, sip_privacy_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_privacy_t.
 * 
 * The function sip_privacy_make() makes a new
 * sip_privacy_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_privacy_make() returns a pointer to
 * newly maked sip_privacy_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_privacy_t *sip_privacy_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_privacy_t *sip_privacy_make(su_home_t *home, char const *s)
{
  return (sip_privacy_t *)sip_header_make(home, sip_privacy_class, s);
}
#endif

/**Make a Privacy header from formatting result.
 * 
 * The function sip_privacy_format() makes a new
 * Privacy header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_privacy_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_privacy_t *sip_privacy_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_privacy_t *sip_privacy_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_privacy_class, fmt, ap);
  va_end(ap);
 
  return (sip_privacy_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_etag
 * @{
 */

/** Parse a SIP-ETag header. @internal */
SOFIAPUBFUN int sip_etag_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a SIP-ETag header. @internal */
SOFIAPUBFUN int sip_etag_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_etag_t from sip_t.
 * 
 */
#define sip_etag(sip) \
  ((sip_etag_t *)msg_header_access((msg_pub_t*)(sip), sip_etag_class))

/**Initializer for structure sip_etag_t.
 * 
 * A static sip_etag_t structure must be initialized.
 * The SIP_ETAG_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_etag_t sip_etag = SIP_ETAG_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ETAG_INIT() SIP_HDR_INIT(etag)

/**Initialize a structure sip_etag_t.
 * 
 * An sip_etag_t structure can be initialized with the
 * sip_etag_init() function/macro. For instance,
 * @code
 * 
 *  sip_etag_t sip_etag;
 * 
 *  sip_etag_init(&sip_etag);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_etag_t *sip_etag_init(sip_etag_t x[1])
{
  return SIP_HEADER_INIT(x, sip_etag_class, sizeof(sip_etag_t));
}
#else
#define sip_etag_init(x) \
  SIP_HEADER_INIT(x, sip_etag_class, sizeof(sip_etag_t))
#endif

/**Test if header object is instance of sip_etag_t.
 * 
 * The function sip_is_etag() returns true (nonzero) if
 * the header class is an instance of SIP-ETag header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_etag() returns true (nonzero) if
 * the header object is an instance of header etag and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_etag(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_etag_hash;
}
#else
int sip_is_etag(sip_header_t const *header);
#endif

#define sip_etag_p(h) sip_is_etag((h))


/**Duplicate (deep copy) @c sip_etag_t.
 * 
 * The function sip_etag_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   etag = sip_etag_dup(home, sip->sip_etag);
 * 
 * @endcode
 * 
 * @return
 * The function sip_etag_dup() returns a pointer to the
 * newly duplicated sip_etag_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_etag_t *sip_etag_dup(su_home_t *home, sip_etag_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_etag_t *sip_etag_dup(su_home_t *home, sip_etag_t const *hdr)
{ 
  return (sip_etag_t *)
    msg_header_dup_as(home, sip_etag_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_etag_t header structure.
 * 
 * The function sip_etag_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   etag = sip_etag_copy(home, sip->sip_etag);
 * 
 * @endcode
 * 
 * @return
 * The function sip_etag_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_etag_t *sip_etag_copy(su_home_t *home, sip_etag_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_etag_t *sip_etag_copy(su_home_t *home, sip_etag_t const *hdr) 
{ 
  return (sip_etag_t *)
    msg_header_copy_as(home, sip_etag_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_etag_t.
 * 
 * The function sip_etag_make() makes a new
 * sip_etag_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_etag_make() returns a pointer to
 * newly maked sip_etag_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_etag_t *sip_etag_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_etag_t *sip_etag_make(su_home_t *home, char const *s)
{
  return (sip_etag_t *)sip_header_make(home, sip_etag_class, s);
}
#endif

/**Make a SIP-ETag header from formatting result.
 * 
 * The function sip_etag_format() makes a new
 * SIP-ETag header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_etag_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_etag_t *sip_etag_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_etag_t *sip_etag_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_etag_class, fmt, ap);
  va_end(ap);
 
  return (sip_etag_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_if_match
 * @{
 */

/** Parse a SIP-If-Match header. @internal */
SOFIAPUBFUN int sip_if_match_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a SIP-If-Match header. @internal */
SOFIAPUBFUN int sip_if_match_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_if_match_t from sip_t.
 * 
 */
#define sip_if_match(sip) \
  ((sip_if_match_t *)msg_header_access((msg_pub_t*)(sip), sip_if_match_class))

/**Initializer for structure sip_if_match_t.
 * 
 * A static sip_if_match_t structure must be initialized.
 * The SIP_IF_MATCH_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_if_match_t sip_if_match = SIP_IF_MATCH_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_IF_MATCH_INIT() SIP_HDR_INIT(if_match)

/**Initialize a structure sip_if_match_t.
 * 
 * An sip_if_match_t structure can be initialized with the
 * sip_if_match_init() function/macro. For instance,
 * @code
 * 
 *  sip_if_match_t sip_if_match;
 * 
 *  sip_if_match_init(&sip_if_match);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_if_match_t *sip_if_match_init(sip_if_match_t x[1])
{
  return SIP_HEADER_INIT(x, sip_if_match_class, sizeof(sip_if_match_t));
}
#else
#define sip_if_match_init(x) \
  SIP_HEADER_INIT(x, sip_if_match_class, sizeof(sip_if_match_t))
#endif

/**Test if header object is instance of sip_if_match_t.
 * 
 * The function sip_is_if_match() returns true (nonzero) if
 * the header class is an instance of SIP-If-Match header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_if_match() returns true (nonzero) if
 * the header object is an instance of header if_match and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_if_match(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_if_match_hash;
}
#else
int sip_is_if_match(sip_header_t const *header);
#endif

#define sip_if_match_p(h) sip_is_if_match((h))


/**Duplicate (deep copy) @c sip_if_match_t.
 * 
 * The function sip_if_match_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   if_match = sip_if_match_dup(home, sip->sip_if_match);
 * 
 * @endcode
 * 
 * @return
 * The function sip_if_match_dup() returns a pointer to the
 * newly duplicated sip_if_match_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_if_match_t *sip_if_match_dup(su_home_t *home, sip_if_match_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_if_match_t *sip_if_match_dup(su_home_t *home, sip_if_match_t const *hdr)
{ 
  return (sip_if_match_t *)
    msg_header_dup_as(home, sip_if_match_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_if_match_t header structure.
 * 
 * The function sip_if_match_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   if_match = sip_if_match_copy(home, sip->sip_if_match);
 * 
 * @endcode
 * 
 * @return
 * The function sip_if_match_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_if_match_t *sip_if_match_copy(su_home_t *home, sip_if_match_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_if_match_t *sip_if_match_copy(su_home_t *home, sip_if_match_t const *hdr) 
{ 
  return (sip_if_match_t *)
    msg_header_copy_as(home, sip_if_match_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_if_match_t.
 * 
 * The function sip_if_match_make() makes a new
 * sip_if_match_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_if_match_make() returns a pointer to
 * newly maked sip_if_match_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_if_match_t *sip_if_match_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_if_match_t *sip_if_match_make(su_home_t *home, char const *s)
{
  return (sip_if_match_t *)sip_header_make(home, sip_if_match_class, s);
}
#endif

/**Make a SIP-If-Match header from formatting result.
 * 
 * The function sip_if_match_format() makes a new
 * SIP-If-Match header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_if_match_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_if_match_t *sip_if_match_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_if_match_t *sip_if_match_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_if_match_class, fmt, ap);
  va_end(ap);
 
  return (sip_if_match_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_mime_version
 * @{
 */

/** Parse a MIME-Version header. @internal */
SOFIAPUBFUN int sip_mime_version_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a MIME-Version header. @internal */
SOFIAPUBFUN int sip_mime_version_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_mime_version_t from sip_t.
 * 
 */
#define sip_mime_version(sip) \
  ((sip_mime_version_t *)msg_header_access((msg_pub_t*)(sip), sip_mime_version_class))

/**Initializer for structure sip_mime_version_t.
 * 
 * A static sip_mime_version_t structure must be initialized.
 * The SIP_MIME_VERSION_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_mime_version_t sip_mime_version = SIP_MIME_VERSION_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_MIME_VERSION_INIT() SIP_HDR_INIT(mime_version)

/**Initialize a structure sip_mime_version_t.
 * 
 * An sip_mime_version_t structure can be initialized with the
 * sip_mime_version_init() function/macro. For instance,
 * @code
 * 
 *  sip_mime_version_t sip_mime_version;
 * 
 *  sip_mime_version_init(&sip_mime_version);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_mime_version_t *sip_mime_version_init(sip_mime_version_t x[1])
{
  return SIP_HEADER_INIT(x, sip_mime_version_class, sizeof(sip_mime_version_t));
}
#else
#define sip_mime_version_init(x) \
  SIP_HEADER_INIT(x, sip_mime_version_class, sizeof(sip_mime_version_t))
#endif

/**Test if header object is instance of sip_mime_version_t.
 * 
 * The function sip_is_mime_version() returns true (nonzero) if
 * the header class is an instance of MIME-Version header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_mime_version() returns true (nonzero) if
 * the header object is an instance of header mime_version and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_mime_version(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_mime_version_hash;
}
#else
int sip_is_mime_version(sip_header_t const *header);
#endif

#define sip_mime_version_p(h) sip_is_mime_version((h))


/**Duplicate (deep copy) @c sip_mime_version_t.
 * 
 * The function sip_mime_version_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   mime_version = sip_mime_version_dup(home, sip->sip_mime_version);
 * 
 * @endcode
 * 
 * @return
 * The function sip_mime_version_dup() returns a pointer to the
 * newly duplicated sip_mime_version_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_mime_version_t *sip_mime_version_dup(su_home_t *home, sip_mime_version_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_mime_version_t *sip_mime_version_dup(su_home_t *home, sip_mime_version_t const *hdr)
{ 
  return (sip_mime_version_t *)
    msg_header_dup_as(home, sip_mime_version_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_mime_version_t header structure.
 * 
 * The function sip_mime_version_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   mime_version = sip_mime_version_copy(home, sip->sip_mime_version);
 * 
 * @endcode
 * 
 * @return
 * The function sip_mime_version_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_mime_version_t *sip_mime_version_copy(su_home_t *home, sip_mime_version_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_mime_version_t *sip_mime_version_copy(su_home_t *home, sip_mime_version_t const *hdr) 
{ 
  return (sip_mime_version_t *)
    msg_header_copy_as(home, sip_mime_version_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_mime_version_t.
 * 
 * The function sip_mime_version_make() makes a new
 * sip_mime_version_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_mime_version_make() returns a pointer to
 * newly maked sip_mime_version_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_mime_version_t *sip_mime_version_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_mime_version_t *sip_mime_version_make(su_home_t *home, char const *s)
{
  return (sip_mime_version_t *)sip_header_make(home, sip_mime_version_class, s);
}
#endif

/**Make a MIME-Version header from formatting result.
 * 
 * The function sip_mime_version_format() makes a new
 * MIME-Version header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_mime_version_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_mime_version_t *sip_mime_version_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_mime_version_t *sip_mime_version_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_mime_version_class, fmt, ap);
  va_end(ap);
 
  return (sip_mime_version_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_content_type
 * @{
 */

/** Parse a Content-Type header. @internal */
SOFIAPUBFUN int sip_content_type_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Content-Type header. @internal */
SOFIAPUBFUN int sip_content_type_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_content_type_t from sip_t.
 * 
 */
#define sip_content_type(sip) \
  ((sip_content_type_t *)msg_header_access((msg_pub_t*)(sip), sip_content_type_class))

/**Initializer for structure sip_content_type_t.
 * 
 * A static sip_content_type_t structure must be initialized.
 * The SIP_CONTENT_TYPE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_content_type_t sip_content_type = SIP_CONTENT_TYPE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CONTENT_TYPE_INIT() SIP_HDR_INIT(content_type)

/**Initialize a structure sip_content_type_t.
 * 
 * An sip_content_type_t structure can be initialized with the
 * sip_content_type_init() function/macro. For instance,
 * @code
 * 
 *  sip_content_type_t sip_content_type;
 * 
 *  sip_content_type_init(&sip_content_type);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_content_type_t *sip_content_type_init(sip_content_type_t x[1])
{
  return SIP_HEADER_INIT(x, sip_content_type_class, sizeof(sip_content_type_t));
}
#else
#define sip_content_type_init(x) \
  SIP_HEADER_INIT(x, sip_content_type_class, sizeof(sip_content_type_t))
#endif

/**Test if header object is instance of sip_content_type_t.
 * 
 * The function sip_is_content_type() returns true (nonzero) if
 * the header class is an instance of Content-Type header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_content_type() returns true (nonzero) if
 * the header object is an instance of header content_type and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_content_type(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_content_type_hash;
}
#else
int sip_is_content_type(sip_header_t const *header);
#endif

#define sip_content_type_p(h) sip_is_content_type((h))


/**Duplicate (deep copy) @c sip_content_type_t.
 * 
 * The function sip_content_type_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   content_type = sip_content_type_dup(home, sip->sip_content_type);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_type_dup() returns a pointer to the
 * newly duplicated sip_content_type_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_type_t *sip_content_type_dup(su_home_t *home, sip_content_type_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_type_t *sip_content_type_dup(su_home_t *home, sip_content_type_t const *hdr)
{ 
  return (sip_content_type_t *)
    msg_header_dup_as(home, sip_content_type_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_content_type_t header structure.
 * 
 * The function sip_content_type_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   content_type = sip_content_type_copy(home, sip->sip_content_type);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_type_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_type_t *sip_content_type_copy(su_home_t *home, sip_content_type_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_type_t *sip_content_type_copy(su_home_t *home, sip_content_type_t const *hdr) 
{ 
  return (sip_content_type_t *)
    msg_header_copy_as(home, sip_content_type_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_content_type_t.
 * 
 * The function sip_content_type_make() makes a new
 * sip_content_type_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_content_type_make() returns a pointer to
 * newly maked sip_content_type_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_content_type_t *sip_content_type_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_content_type_t *sip_content_type_make(su_home_t *home, char const *s)
{
  return (sip_content_type_t *)sip_header_make(home, sip_content_type_class, s);
}
#endif

/**Make a Content-Type header from formatting result.
 * 
 * The function sip_content_type_format() makes a new
 * Content-Type header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_content_type_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_type_t *sip_content_type_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_content_type_t *sip_content_type_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_content_type_class, fmt, ap);
  va_end(ap);
 
  return (sip_content_type_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_content_encoding
 * @{
 */

/** Parse a Content-Encoding header. @internal */
SOFIAPUBFUN int sip_content_encoding_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Content-Encoding header. @internal */
SOFIAPUBFUN int sip_content_encoding_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_content_encoding_t from sip_t.
 * 
 */
#define sip_content_encoding(sip) \
  ((sip_content_encoding_t *)msg_header_access((msg_pub_t*)(sip), sip_content_encoding_class))

/**Initializer for structure sip_content_encoding_t.
 * 
 * A static sip_content_encoding_t structure must be initialized.
 * The SIP_CONTENT_ENCODING_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_content_encoding_t sip_content_encoding = SIP_CONTENT_ENCODING_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CONTENT_ENCODING_INIT() SIP_HDR_INIT(content_encoding)

/**Initialize a structure sip_content_encoding_t.
 * 
 * An sip_content_encoding_t structure can be initialized with the
 * sip_content_encoding_init() function/macro. For instance,
 * @code
 * 
 *  sip_content_encoding_t sip_content_encoding;
 * 
 *  sip_content_encoding_init(&sip_content_encoding);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_content_encoding_t *sip_content_encoding_init(sip_content_encoding_t x[1])
{
  return SIP_HEADER_INIT(x, sip_content_encoding_class, sizeof(sip_content_encoding_t));
}
#else
#define sip_content_encoding_init(x) \
  SIP_HEADER_INIT(x, sip_content_encoding_class, sizeof(sip_content_encoding_t))
#endif

/**Test if header object is instance of sip_content_encoding_t.
 * 
 * The function sip_is_content_encoding() returns true (nonzero) if
 * the header class is an instance of Content-Encoding header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_content_encoding() returns true (nonzero) if
 * the header object is an instance of header content_encoding and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_content_encoding(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_content_encoding_hash;
}
#else
int sip_is_content_encoding(sip_header_t const *header);
#endif

#define sip_content_encoding_p(h) sip_is_content_encoding((h))


/**Duplicate (deep copy) @c sip_content_encoding_t.
 * 
 * The function sip_content_encoding_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   content_encoding = sip_content_encoding_dup(home, sip->sip_content_encoding);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_encoding_dup() returns a pointer to the
 * newly duplicated sip_content_encoding_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_encoding_t *sip_content_encoding_dup(su_home_t *home, sip_content_encoding_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_encoding_t *sip_content_encoding_dup(su_home_t *home, sip_content_encoding_t const *hdr)
{ 
  return (sip_content_encoding_t *)
    msg_header_dup_as(home, sip_content_encoding_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_content_encoding_t header structure.
 * 
 * The function sip_content_encoding_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   content_encoding = sip_content_encoding_copy(home, sip->sip_content_encoding);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_encoding_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_encoding_t *sip_content_encoding_copy(su_home_t *home, sip_content_encoding_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_encoding_t *sip_content_encoding_copy(su_home_t *home, sip_content_encoding_t const *hdr) 
{ 
  return (sip_content_encoding_t *)
    msg_header_copy_as(home, sip_content_encoding_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_content_encoding_t.
 * 
 * The function sip_content_encoding_make() makes a new
 * sip_content_encoding_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_content_encoding_make() returns a pointer to
 * newly maked sip_content_encoding_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_content_encoding_t *sip_content_encoding_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_content_encoding_t *sip_content_encoding_make(su_home_t *home, char const *s)
{
  return (sip_content_encoding_t *)sip_header_make(home, sip_content_encoding_class, s);
}
#endif

/**Make a Content-Encoding header from formatting result.
 * 
 * The function sip_content_encoding_format() makes a new
 * Content-Encoding header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_content_encoding_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_encoding_t *sip_content_encoding_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_content_encoding_t *sip_content_encoding_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_content_encoding_class, fmt, ap);
  va_end(ap);
 
  return (sip_content_encoding_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_content_language
 * @{
 */

/** Parse a Content-Language header. @internal */
SOFIAPUBFUN int sip_content_language_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Content-Language header. @internal */
SOFIAPUBFUN int sip_content_language_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_content_language_t from sip_t.
 * 
 */
#define sip_content_language(sip) \
  ((sip_content_language_t *)msg_header_access((msg_pub_t*)(sip), sip_content_language_class))

/**Initializer for structure sip_content_language_t.
 * 
 * A static sip_content_language_t structure must be initialized.
 * The SIP_CONTENT_LANGUAGE_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_content_language_t sip_content_language = SIP_CONTENT_LANGUAGE_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CONTENT_LANGUAGE_INIT() SIP_HDR_INIT(content_language)

/**Initialize a structure sip_content_language_t.
 * 
 * An sip_content_language_t structure can be initialized with the
 * sip_content_language_init() function/macro. For instance,
 * @code
 * 
 *  sip_content_language_t sip_content_language;
 * 
 *  sip_content_language_init(&sip_content_language);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_content_language_t *sip_content_language_init(sip_content_language_t x[1])
{
  return SIP_HEADER_INIT(x, sip_content_language_class, sizeof(sip_content_language_t));
}
#else
#define sip_content_language_init(x) \
  SIP_HEADER_INIT(x, sip_content_language_class, sizeof(sip_content_language_t))
#endif

/**Test if header object is instance of sip_content_language_t.
 * 
 * The function sip_is_content_language() returns true (nonzero) if
 * the header class is an instance of Content-Language header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_content_language() returns true (nonzero) if
 * the header object is an instance of header content_language and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_content_language(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_content_language_hash;
}
#else
int sip_is_content_language(sip_header_t const *header);
#endif

#define sip_content_language_p(h) sip_is_content_language((h))


/**Duplicate (deep copy) @c sip_content_language_t.
 * 
 * The function sip_content_language_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   content_language = sip_content_language_dup(home, sip->sip_content_language);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_language_dup() returns a pointer to the
 * newly duplicated sip_content_language_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_language_t *sip_content_language_dup(su_home_t *home, sip_content_language_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_language_t *sip_content_language_dup(su_home_t *home, sip_content_language_t const *hdr)
{ 
  return (sip_content_language_t *)
    msg_header_dup_as(home, sip_content_language_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_content_language_t header structure.
 * 
 * The function sip_content_language_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   content_language = sip_content_language_copy(home, sip->sip_content_language);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_language_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_language_t *sip_content_language_copy(su_home_t *home, sip_content_language_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_language_t *sip_content_language_copy(su_home_t *home, sip_content_language_t const *hdr) 
{ 
  return (sip_content_language_t *)
    msg_header_copy_as(home, sip_content_language_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_content_language_t.
 * 
 * The function sip_content_language_make() makes a new
 * sip_content_language_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_content_language_make() returns a pointer to
 * newly maked sip_content_language_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_content_language_t *sip_content_language_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_content_language_t *sip_content_language_make(su_home_t *home, char const *s)
{
  return (sip_content_language_t *)sip_header_make(home, sip_content_language_class, s);
}
#endif

/**Make a Content-Language header from formatting result.
 * 
 * The function sip_content_language_format() makes a new
 * Content-Language header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_content_language_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_language_t *sip_content_language_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_content_language_t *sip_content_language_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_content_language_class, fmt, ap);
  va_end(ap);
 
  return (sip_content_language_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_content_disposition
 * @{
 */

/** Parse a Content-Disposition header. @internal */
SOFIAPUBFUN int sip_content_disposition_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Content-Disposition header. @internal */
SOFIAPUBFUN int sip_content_disposition_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_content_disposition_t from sip_t.
 * 
 */
#define sip_content_disposition(sip) \
  ((sip_content_disposition_t *)msg_header_access((msg_pub_t*)(sip), sip_content_disposition_class))

/**Initializer for structure sip_content_disposition_t.
 * 
 * A static sip_content_disposition_t structure must be initialized.
 * The SIP_CONTENT_DISPOSITION_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_content_disposition_t sip_content_disposition = SIP_CONTENT_DISPOSITION_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CONTENT_DISPOSITION_INIT() SIP_HDR_INIT(content_disposition)

/**Initialize a structure sip_content_disposition_t.
 * 
 * An sip_content_disposition_t structure can be initialized with the
 * sip_content_disposition_init() function/macro. For instance,
 * @code
 * 
 *  sip_content_disposition_t sip_content_disposition;
 * 
 *  sip_content_disposition_init(&sip_content_disposition);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_content_disposition_t *sip_content_disposition_init(sip_content_disposition_t x[1])
{
  return SIP_HEADER_INIT(x, sip_content_disposition_class, sizeof(sip_content_disposition_t));
}
#else
#define sip_content_disposition_init(x) \
  SIP_HEADER_INIT(x, sip_content_disposition_class, sizeof(sip_content_disposition_t))
#endif

/**Test if header object is instance of sip_content_disposition_t.
 * 
 * The function sip_is_content_disposition() returns true (nonzero) if
 * the header class is an instance of Content-Disposition header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_content_disposition() returns true (nonzero) if
 * the header object is an instance of header content_disposition and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_content_disposition(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_content_disposition_hash;
}
#else
int sip_is_content_disposition(sip_header_t const *header);
#endif

#define sip_content_disposition_p(h) sip_is_content_disposition((h))


/**Duplicate (deep copy) @c sip_content_disposition_t.
 * 
 * The function sip_content_disposition_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   content_disposition = sip_content_disposition_dup(home, sip->sip_content_disposition);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_disposition_dup() returns a pointer to the
 * newly duplicated sip_content_disposition_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_disposition_t *sip_content_disposition_dup(su_home_t *home, sip_content_disposition_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_disposition_t *sip_content_disposition_dup(su_home_t *home, sip_content_disposition_t const *hdr)
{ 
  return (sip_content_disposition_t *)
    msg_header_dup_as(home, sip_content_disposition_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_content_disposition_t header structure.
 * 
 * The function sip_content_disposition_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   content_disposition = sip_content_disposition_copy(home, sip->sip_content_disposition);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_disposition_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_disposition_t *sip_content_disposition_copy(su_home_t *home, sip_content_disposition_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_disposition_t *sip_content_disposition_copy(su_home_t *home, sip_content_disposition_t const *hdr) 
{ 
  return (sip_content_disposition_t *)
    msg_header_copy_as(home, sip_content_disposition_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_content_disposition_t.
 * 
 * The function sip_content_disposition_make() makes a new
 * sip_content_disposition_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_content_disposition_make() returns a pointer to
 * newly maked sip_content_disposition_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_content_disposition_t *sip_content_disposition_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_content_disposition_t *sip_content_disposition_make(su_home_t *home, char const *s)
{
  return (sip_content_disposition_t *)sip_header_make(home, sip_content_disposition_class, s);
}
#endif

/**Make a Content-Disposition header from formatting result.
 * 
 * The function sip_content_disposition_format() makes a new
 * Content-Disposition header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_content_disposition_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_disposition_t *sip_content_disposition_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_content_disposition_t *sip_content_disposition_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_content_disposition_class, fmt, ap);
  va_end(ap);
 
  return (sip_content_disposition_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_content_length
 * @{
 */

/** Parse a Content-Length header. @internal */
SOFIAPUBFUN int sip_content_length_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a Content-Length header. @internal */
SOFIAPUBFUN int sip_content_length_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_content_length_t from sip_t.
 * 
 */
#define sip_content_length(sip) \
  ((sip_content_length_t *)msg_header_access((msg_pub_t*)(sip), sip_content_length_class))

/**Initializer for structure sip_content_length_t.
 * 
 * A static sip_content_length_t structure must be initialized.
 * The SIP_CONTENT_LENGTH_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_content_length_t sip_content_length = SIP_CONTENT_LENGTH_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_CONTENT_LENGTH_INIT() SIP_HDR_INIT(content_length)

/**Initialize a structure sip_content_length_t.
 * 
 * An sip_content_length_t structure can be initialized with the
 * sip_content_length_init() function/macro. For instance,
 * @code
 * 
 *  sip_content_length_t sip_content_length;
 * 
 *  sip_content_length_init(&sip_content_length);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_content_length_t *sip_content_length_init(sip_content_length_t x[1])
{
  return SIP_HEADER_INIT(x, sip_content_length_class, sizeof(sip_content_length_t));
}
#else
#define sip_content_length_init(x) \
  SIP_HEADER_INIT(x, sip_content_length_class, sizeof(sip_content_length_t))
#endif

/**Test if header object is instance of sip_content_length_t.
 * 
 * The function sip_is_content_length() returns true (nonzero) if
 * the header class is an instance of Content-Length header
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_content_length() returns true (nonzero) if
 * the header object is an instance of header content_length and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_content_length(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_content_length_hash;
}
#else
int sip_is_content_length(sip_header_t const *header);
#endif

#define sip_content_length_p(h) sip_is_content_length((h))


/**Duplicate (deep copy) @c sip_content_length_t.
 * 
 * The function sip_content_length_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   content_length = sip_content_length_dup(home, sip->sip_content_length);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_length_dup() returns a pointer to the
 * newly duplicated sip_content_length_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_length_t *sip_content_length_dup(su_home_t *home, sip_content_length_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_length_t *sip_content_length_dup(su_home_t *home, sip_content_length_t const *hdr)
{ 
  return (sip_content_length_t *)
    msg_header_dup_as(home, sip_content_length_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_content_length_t header structure.
 * 
 * The function sip_content_length_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   content_length = sip_content_length_copy(home, sip->sip_content_length);
 * 
 * @endcode
 * 
 * @return
 * The function sip_content_length_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_length_t *sip_content_length_copy(su_home_t *home, sip_content_length_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_content_length_t *sip_content_length_copy(su_home_t *home, sip_content_length_t const *hdr) 
{ 
  return (sip_content_length_t *)
    msg_header_copy_as(home, sip_content_length_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_content_length_t.
 * 
 * The function sip_content_length_make() makes a new
 * sip_content_length_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_content_length_make() returns a pointer to
 * newly maked sip_content_length_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_content_length_t *sip_content_length_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_content_length_t *sip_content_length_make(su_home_t *home, char const *s)
{
  return (sip_content_length_t *)sip_header_make(home, sip_content_length_class, s);
}
#endif

/**Make a Content-Length header from formatting result.
 * 
 * The function sip_content_length_format() makes a new
 * Content-Length header object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_content_length_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_content_length_t *sip_content_length_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_content_length_t *sip_content_length_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_content_length_class, fmt, ap);
  va_end(ap);
 
  return (sip_content_length_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_unknown
 * @{
 */

/** Parse a unknown headers. @internal */
SOFIAPUBFUN int sip_unknown_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a unknown headers. @internal */
SOFIAPUBFUN int sip_unknown_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_unknown_t from sip_t.
 * 
 */
#define sip_unknown(sip) \
  ((sip_unknown_t *)msg_header_access((msg_pub_t*)(sip), sip_unknown_class))

/**Initializer for structure sip_unknown_t.
 * 
 * A static sip_unknown_t structure must be initialized.
 * The SIP_UNKNOWN_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_unknown_t sip_unknown = SIP_UNKNOWN_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_UNKNOWN_INIT() SIP_HDR_INIT(unknown)

/**Initialize a structure sip_unknown_t.
 * 
 * An sip_unknown_t structure can be initialized with the
 * sip_unknown_init() function/macro. For instance,
 * @code
 * 
 *  sip_unknown_t sip_unknown;
 * 
 *  sip_unknown_init(&sip_unknown);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_unknown_t *sip_unknown_init(sip_unknown_t x[1])
{
  return SIP_HEADER_INIT(x, sip_unknown_class, sizeof(sip_unknown_t));
}
#else
#define sip_unknown_init(x) \
  SIP_HEADER_INIT(x, sip_unknown_class, sizeof(sip_unknown_t))
#endif

/**Test if header object is instance of sip_unknown_t.
 * 
 * The function sip_is_unknown() returns true (nonzero) if
 * the header class is an instance of unknown headers
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_unknown() returns true (nonzero) if
 * the header object is an instance of header unknown and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_unknown(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_unknown_hash;
}
#else
int sip_is_unknown(sip_header_t const *header);
#endif

#define sip_unknown_p(h) sip_is_unknown((h))


/**Duplicate (deep copy) @c sip_unknown_t.
 * 
 * The function sip_unknown_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   unknown = sip_unknown_dup(home, sip->sip_unknown);
 * 
 * @endcode
 * 
 * @return
 * The function sip_unknown_dup() returns a pointer to the
 * newly duplicated sip_unknown_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_unknown_t *sip_unknown_dup(su_home_t *home, sip_unknown_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_unknown_t *sip_unknown_dup(su_home_t *home, sip_unknown_t const *hdr)
{ 
  return (sip_unknown_t *)
    msg_header_dup_as(home, sip_unknown_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_unknown_t header structure.
 * 
 * The function sip_unknown_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   unknown = sip_unknown_copy(home, sip->sip_unknown);
 * 
 * @endcode
 * 
 * @return
 * The function sip_unknown_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_unknown_t *sip_unknown_copy(su_home_t *home, sip_unknown_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_unknown_t *sip_unknown_copy(su_home_t *home, sip_unknown_t const *hdr) 
{ 
  return (sip_unknown_t *)
    msg_header_copy_as(home, sip_unknown_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_unknown_t.
 * 
 * The function sip_unknown_make() makes a new
 * sip_unknown_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_unknown_make() returns a pointer to
 * newly maked sip_unknown_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_unknown_t *sip_unknown_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_unknown_t *sip_unknown_make(su_home_t *home, char const *s)
{
  return (sip_unknown_t *)sip_header_make(home, sip_unknown_class, s);
}
#endif

/**Make a unknown headers from formatting result.
 * 
 * The function sip_unknown_format() makes a new
 * unknown headers object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_unknown_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_unknown_t *sip_unknown_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_unknown_t *sip_unknown_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_unknown_class, fmt, ap);
  va_end(ap);
 
  return (sip_unknown_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_error
 * @{
 */

/** Parse a erroneous headers. @internal */
SOFIAPUBFUN int sip_error_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a erroneous headers. @internal */
SOFIAPUBFUN int sip_error_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_error_t from sip_t.
 * 
 */
#define sip_error(sip) \
  ((sip_error_t *)msg_header_access((msg_pub_t*)(sip), sip_error_class))

/**Initializer for structure sip_error_t.
 * 
 * A static sip_error_t structure must be initialized.
 * The SIP_ERROR_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_error_t sip_error = SIP_ERROR_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_ERROR_INIT() SIP_HDR_INIT(error)

/**Initialize a structure sip_error_t.
 * 
 * An sip_error_t structure can be initialized with the
 * sip_error_init() function/macro. For instance,
 * @code
 * 
 *  sip_error_t sip_error;
 * 
 *  sip_error_init(&sip_error);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_error_t *sip_error_init(sip_error_t x[1])
{
  return SIP_HEADER_INIT(x, sip_error_class, sizeof(sip_error_t));
}
#else
#define sip_error_init(x) \
  SIP_HEADER_INIT(x, sip_error_class, sizeof(sip_error_t))
#endif

/**Test if header object is instance of sip_error_t.
 * 
 * The function sip_is_error() returns true (nonzero) if
 * the header class is an instance of erroneous headers
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_error() returns true (nonzero) if
 * the header object is an instance of header error and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_error(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_error_hash;
}
#else
int sip_is_error(sip_header_t const *header);
#endif

#define sip_error_p(h) sip_is_error((h))


/**Duplicate (deep copy) @c sip_error_t.
 * 
 * The function sip_error_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   error = sip_error_dup(home, sip->sip_error);
 * 
 * @endcode
 * 
 * @return
 * The function sip_error_dup() returns a pointer to the
 * newly duplicated sip_error_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_error_t *sip_error_dup(su_home_t *home, sip_error_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_error_t *sip_error_dup(su_home_t *home, sip_error_t const *hdr)
{ 
  return (sip_error_t *)
    msg_header_dup_as(home, sip_error_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_error_t header structure.
 * 
 * The function sip_error_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   error = sip_error_copy(home, sip->sip_error);
 * 
 * @endcode
 * 
 * @return
 * The function sip_error_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_error_t *sip_error_copy(su_home_t *home, sip_error_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_error_t *sip_error_copy(su_home_t *home, sip_error_t const *hdr) 
{ 
  return (sip_error_t *)
    msg_header_copy_as(home, sip_error_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_error_t.
 * 
 * The function sip_error_make() makes a new
 * sip_error_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_error_make() returns a pointer to
 * newly maked sip_error_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_error_t *sip_error_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_error_t *sip_error_make(su_home_t *home, char const *s)
{
  return (sip_error_t *)sip_header_make(home, sip_error_class, s);
}
#endif

/**Make a erroneous headers from formatting result.
 * 
 * The function sip_error_format() makes a new
 * erroneous headers object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_error_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_error_t *sip_error_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_error_t *sip_error_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_error_class, fmt, ap);
  va_end(ap);
 
  return (sip_error_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_separator
 * @{
 */

/** Parse a separator line between headers and payload. @internal */
SOFIAPUBFUN int sip_separator_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a separator line between headers and payload. @internal */
SOFIAPUBFUN int sip_separator_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_separator_t from sip_t.
 * 
 */
#define sip_separator(sip) \
  ((sip_separator_t *)msg_header_access((msg_pub_t*)(sip), sip_separator_class))

/**Initializer for structure sip_separator_t.
 * 
 * A static sip_separator_t structure must be initialized.
 * The SIP_SEPARATOR_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_separator_t sip_separator = SIP_SEPARATOR_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_SEPARATOR_INIT() SIP_HDR_INIT(separator)

/**Initialize a structure sip_separator_t.
 * 
 * An sip_separator_t structure can be initialized with the
 * sip_separator_init() function/macro. For instance,
 * @code
 * 
 *  sip_separator_t sip_separator;
 * 
 *  sip_separator_init(&sip_separator);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_separator_t *sip_separator_init(sip_separator_t x[1])
{
  return SIP_HEADER_INIT(x, sip_separator_class, sizeof(sip_separator_t));
}
#else
#define sip_separator_init(x) \
  SIP_HEADER_INIT(x, sip_separator_class, sizeof(sip_separator_t))
#endif

/**Test if header object is instance of sip_separator_t.
 * 
 * The function sip_is_separator() returns true (nonzero) if
 * the header class is an instance of separator line between headers and payload
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_separator() returns true (nonzero) if
 * the header object is an instance of header separator and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_separator(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_separator_hash;
}
#else
int sip_is_separator(sip_header_t const *header);
#endif

#define sip_separator_p(h) sip_is_separator((h))


/**Duplicate (deep copy) @c sip_separator_t.
 * 
 * The function sip_separator_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   separator = sip_separator_dup(home, sip->sip_separator);
 * 
 * @endcode
 * 
 * @return
 * The function sip_separator_dup() returns a pointer to the
 * newly duplicated sip_separator_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_separator_t *sip_separator_dup(su_home_t *home, sip_separator_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_separator_t *sip_separator_dup(su_home_t *home, sip_separator_t const *hdr)
{ 
  return (sip_separator_t *)
    msg_header_dup_as(home, sip_separator_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_separator_t header structure.
 * 
 * The function sip_separator_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   separator = sip_separator_copy(home, sip->sip_separator);
 * 
 * @endcode
 * 
 * @return
 * The function sip_separator_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_separator_t *sip_separator_copy(su_home_t *home, sip_separator_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_separator_t *sip_separator_copy(su_home_t *home, sip_separator_t const *hdr) 
{ 
  return (sip_separator_t *)
    msg_header_copy_as(home, sip_separator_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_separator_t.
 * 
 * The function sip_separator_make() makes a new
 * sip_separator_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_separator_make() returns a pointer to
 * newly maked sip_separator_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_separator_t *sip_separator_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_separator_t *sip_separator_make(su_home_t *home, char const *s)
{
  return (sip_separator_t *)sip_header_make(home, sip_separator_class, s);
}
#endif

/**Make a separator line between headers and payload from formatting result.
 * 
 * The function sip_separator_format() makes a new
 * separator line between headers and payload object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_separator_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_separator_t *sip_separator_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_separator_t *sip_separator_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_separator_class, fmt, ap);
  va_end(ap);
 
  return (sip_separator_t *)h;
}
#endif

/** @} */

/**@addtogroup sip_payload
 * @{
 */

/** Parse a message payload. @internal */
SOFIAPUBFUN int sip_payload_d(su_home_t *, msg_header_t *,
			       char *s, int slen);

/** Print a message payload. @internal */
SOFIAPUBFUN int sip_payload_e(char b[], int bsiz,
                               msg_header_t const *h, int flags);

/**Access a sip_payload_t from sip_t.
 * 
 */
#define sip_payload(sip) \
  ((sip_payload_t *)msg_header_access((msg_pub_t*)(sip), sip_payload_class))

/**Initializer for structure sip_payload_t.
 * 
 * A static sip_payload_t structure must be initialized.
 * The SIP_PAYLOAD_INIT() macro provides initialization value. 
 * For instance,
 * @code 
 * 
 *  sip_payload_t sip_payload = SIP_PAYLOAD_INIT;
 * 
 * @endcode
 * @HI
 */
#define SIP_PAYLOAD_INIT() SIP_HDR_INIT(payload)

/**Initialize a structure sip_payload_t.
 * 
 * An sip_payload_t structure can be initialized with the
 * sip_payload_init() function/macro. For instance,
 * @code
 * 
 *  sip_payload_t sip_payload;
 * 
 *  sip_payload_init(&sip_payload);
 * 
 * @endcode
 * @HI
 */
#if SU_HAVE_INLINE
su_inline sip_payload_t *sip_payload_init(sip_payload_t x[1])
{
  return SIP_HEADER_INIT(x, sip_payload_class, sizeof(sip_payload_t));
}
#else
#define sip_payload_init(x) \
  SIP_HEADER_INIT(x, sip_payload_class, sizeof(sip_payload_t))
#endif

/**Test if header object is instance of sip_payload_t.
 * 
 * The function sip_is_payload() returns true (nonzero) if
 * the header class is an instance of message payload
 * object and false (zero) otherwise.
 * 
 * @param header pointer to the header structure to be tested
 * 
 * @return
 * The function sip_is_payload() returns true (nonzero) if
 * the header object is an instance of header payload and
 * false (zero) otherwise.
 */
#if SU_HAVE_INLINE
su_inline int sip_is_payload(sip_header_t const *header)
{
  return header && header->sh_class->hc_hash == sip_payload_hash;
}
#else
int sip_is_payload(sip_header_t const *header);
#endif

#define sip_payload_p(h) sip_is_payload((h))


/**Duplicate (deep copy) @c sip_payload_t.
 * 
 * The function sip_payload_dup() duplicates a header
 * structure @a hdr.  If the header structure @a hdr
 * contains a reference (@c hdr->x_next) to a list of
 * headers, all the headers in the list are duplicated, too.
 * 
 * @param home  memory home used to allocate new structure
 * @param hdr   header structure to be duplicated
 * 
 * When duplicating, all parameter lists and non-constant
 * strings attached to the header are copied, too.  The
 * function uses given memory @a home to allocate all the
 * memory areas used to copy the header.
 * 
 * @par Example
 * @code
 * 
 *   payload = sip_payload_dup(home, sip->sip_payload);
 * 
 * @endcode
 * 
 * @return
 * The function sip_payload_dup() returns a pointer to the
 * newly duplicated sip_payload_t header structure, or NULL
 * upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_payload_t *sip_payload_dup(su_home_t *home, sip_payload_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_payload_t *sip_payload_dup(su_home_t *home, sip_payload_t const *hdr)
{ 
  return (sip_payload_t *)
    msg_header_dup_as(home, sip_payload_class, (msg_header_t const *)hdr);
}
#endif

/**Copy a sip_payload_t header structure.
 * 
 * The function sip_payload_copy() copies a header structure @a
 * hdr.  If the header structure @a hdr contains a reference (@c
 * hdr->h_next) to a list of headers, all the headers in that
 * list are copied, too. The function uses given memory @a home
 * to allocate all the memory areas used to copy the header
 * structure @a hdr.
 * 
 * @param home    memory home used to allocate new structure
 * @param hdr     pointer to the header structure to be copied
 * 
 * When copying, only the header structure and parameter lists attached to
 * it are duplicated. The new header structure retains all the references to
 * the strings within the old @a hdr header, including the encoding of the
 * old header, if present.
 * 
 * @par Example
 * @code
 * 
 *   payload = sip_payload_copy(home, sip->sip_payload);
 * 
 * @endcode
 * 
 * @return
 * The function sip_payload_copy() returns a pointer to
 * newly copied header structure, or NULL upon an error.
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_payload_t *sip_payload_copy(su_home_t *home, sip_payload_t const *hdr) 
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline
sip_payload_t *sip_payload_copy(su_home_t *home, sip_payload_t const *hdr) 
{ 
  return (sip_payload_t *)
    msg_header_copy_as(home, sip_payload_class, (msg_header_t const *)hdr); 
}
#endif

/**Make a header structure sip_payload_t.
 * 
 * The function sip_payload_make() makes a new
 * sip_payload_t header structure.  It allocates a new
 * header structure, and decodes the string @a s as the
 * value of the structure.
 * 
 * @param home memory home used to allocate new header structure.
 * @param s    string to be decoded as value of the new header structure
 * 
 * @note This function is usually implemented as a macro calling
 * sip_header_make().
 * 
 * @return
 * The function sip_payload_make() returns a pointer to
 * newly maked sip_payload_t header structure, or NULL upon
 * an error.
 */
#if SU_HAVE_INLINE
su_inline 
#endif
sip_payload_t *sip_payload_make(su_home_t *home, char const *s)
     __attribute__((__malloc__));

#if SU_HAVE_INLINE
su_inline sip_payload_t *sip_payload_make(su_home_t *home, char const *s)
{
  return (sip_payload_t *)sip_header_make(home, sip_payload_class, s);
}
#endif

/**Make a message payload from formatting result.
 * 
 * The function sip_payload_format() makes a new
 * message payload object using formatting result as its
 * value.  The function first prints the arguments according to
 * the format @a fmt specified.  Then it allocates a new header
 * structure, and uses the formatting result as the header
 * value.
 * 
 * @param home   memory home used to allocate new header structure.
 * @param fmt    string used as a printf()-style format
 * @param ...    argument list for format
 * 
 * @note This function is usually implemented as a macro calling
 * msg_header_format().
 * 
 * @return
 * The function sip_payload_format() returns a pointer to newly
 * makes header structure, or NULL upon an error.
 * 
 * @HIDE
 */
#if SU_HAVE_INLINE
su_inline
#endif
sip_payload_t *sip_payload_format(su_home_t *home, char const *fmt, ...)
     __attribute__((__malloc__, __format__ (printf, 2, 3)));

#if SU_HAVE_INLINE
su_inline sip_payload_t *sip_payload_format(su_home_t *home, char const *fmt, ...)
{
  sip_header_t *h;
  va_list ap;
  
  va_start(ap, fmt);
  h = sip_header_vformat(home, sip_payload_class, fmt, ap);
  va_end(ap);
 
  return (sip_payload_t *)h;
}
#endif

/** @} */

SOFIA_END_DECLS
#endif /* !defined(SIP_PROTOS_H) */
